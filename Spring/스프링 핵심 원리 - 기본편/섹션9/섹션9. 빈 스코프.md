TOC
- [빈 스코프란?](#빈-스코프란)
- [프로토타입 스코프](#프로토타입-스코프)
- [프로토타입 스코프 - 싱글톤 빈과 함께 사용 시 문제점](#프로토타입-스코프---싱글톤-빈과-함께-사용-시-문제점)
  - [프로토타입 빈 직접 요청](#프로토타입-빈-직접-요청)
  - [싱글톤 빈에서 프로토타입 빈 사용](#싱글톤-빈에서-프로토타입-빈-사용)
- [프로토타입 스코프 - 싱글톤 빈과 함께 사용 시 Provider로 문제 해결](#프로토타입-스코프---싱글톤-빈과-함께-사용-시-provider로-문제-해결)
- [웹 스코프](#웹-스코프)
- [request 스코프 예제 만들기](#request-스코프-예제-만들기)
- [스코프와 Provider](#스코프와-provider)
- [스코프와 프록시](#스코프와-프록시)

# 빈 스코프란?
> 빈 스코프: 빈이 존재할 수 있는 범위

스프링 빈은 기본적으로 싱글톤 스코프로 생성된다.
- 따라서 스프링 컨테이너가 종료될 때까지 유지

스프링은 아래와 같은 스코프를 지원
- **싱글톤**: 기본 스코프, 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프
- **프로토타입**: 스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입까지만 관여하고 더는 관리하지 않는 매우 짧은 범위의 스코프
  - 종료 메소드 호출이 불가능!
- **웹 관련 스코프**: 스프링 웹과 관련된 기능이 들어가야 사용할 수 있는 스코프
  - **request**: 웹 요청이 들어오고 나갈때 까지 유지되는 스코프
  - **session**: 웹 세션이 생성되고 종료될 때 까지 유지되는 스코프 -> 로그인에서 많이 사용
  - **application**: 웹의 서블릿 컨텍스트와 같은 범위로 유지되는 스코프

**빈 스코프 지정 방법**
- `@Scope("prototype")` 사용

---

# 프로토타입 스코프
프로토타입 스코프를 스프링 컨테이너에 조회하면 스프링 컨테이너는 **항상 새로운 인스턴스를 생성, 의존관계 주입, 초기화해서 반환**

![prototype](./image/prototype.png)
- **요청 시**(`ac.getBean()`)에 프로토타입 빈을 생성하고, 의존관계를 주입, 초기화
- 생성한 빈을 반환

=> 따라서 매번 다른 빈을 반환받게 된다!

> 프로타타입 빈을 관리할 책임은 프로토타입 빈을 받은 클라이언트에 있기에, 스프링 컨테이너가 종료될때, `@PreDestroy` 같은 종료 메소드가 호출되지 않는다.

---

# 프로토타입 스코프 - 싱글톤 빈과 함께 사용 시 문제점
싱글톤 빈과 함께 사용하는 경우, 프로토타입 스코프의 빈이어도 항상 새로운 객체 인스턴스를 생성해서 반환하지 않을 수도 있다.

## 프로토타입 빈 직접 요청
![prob1](./image/prob1.png)
- 프로토타입 빈을 요청해서, 새로 생성된 빈을 반환받았다.
- 그리고 그 빈의 `addCount()`를 호출해, 해당 빈의 `count` 필드 값을 변경했다.

![prob2](./image/prob2.png)
- 다른 클라이언트가 동일한 빈을 요청해서, 새로 생성된 빈을 반환받았다.
- 위 클라이언트와 동일한 작업을 수행했다.

## 싱글톤 빈에서 프로토타입 빈 사용
`clientBean` 이라는 싱글톤 빈이 의존관계 주입을 통해 프로토타입 빈을 주입받는 상황을 가정해보자.

![prob3](./image/prob3.png)
- `clientBean` 은 컨테이너 생성 시점에 이미 빈이 생성되었다.
- 그리고 이때, **의존 관계가 있는 프로토타입 빈을 생성해서 주입**받았다.
- 이후 `clientBean` 은 **프로토타입 빈의 참조값**을 내부 필드로서 관리한다.

![prob5](./image/prob5.png)
- 클라이언트 A가 `clientBean` 을 요청해 컨테이너로부터 받는다.
- 이후 A가 `clientBean.logic()`을 호출하고, 해당 로직은 prototypeBean의 `addCount()`를 호출한다.
  - 이제 `prototypeBean` 의 `count` 는 1이다.

![prob6](./image/prob6.png)
- 클라이언트 B가 A와 동일한 로직을 수행하고, 결과적으로 `prototypeBean` 의 `count` 는 2이다.

> 중요한 점은, `prototypeBean` 은 여기서 실제로 프로토타입 스코프를 가지고 있지 않다는 것이다.
> - 이미 과거에 주입이 끝났고, 사용할 때마다 새로 생성이 되는 것이 아니다!!!

스프링은 싱글톤 빈을 일반적으로 사용하기에, 싱글톤 빈이 프로토타입 빈을 사용하게 될 것이다. 프로토타입 빈은 싱글톤 빈과 함께 유지되어, 사용할 때마다 새로 생성되지는 않을 것이다.

---

# 프로토타입 스코프 - 싱글톤 빈과 함께 사용 시 Provider로 문제 해결


---

# 웹 스코프

---

# request 스코프 예제 만들기

---

# 스코프와 Provider

---

# 스코프와 프록시
