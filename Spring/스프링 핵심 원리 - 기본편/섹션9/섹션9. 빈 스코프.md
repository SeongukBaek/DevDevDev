TOC
- [빈 스코프란?](#빈-스코프란)
- [프로토타입 스코프](#프로토타입-스코프)
- [프로토타입 스코프 - 싱글톤 빈과 함께 사용 시 문제점](#프로토타입-스코프---싱글톤-빈과-함께-사용-시-문제점)
  - [프로토타입 빈 직접 요청](#프로토타입-빈-직접-요청)
  - [싱글톤 빈에서 프로토타입 빈 사용](#싱글톤-빈에서-프로토타입-빈-사용)
- [프로토타입 스코프 - 싱글톤 빈과 함께 사용 시 Provider로 문제 해결](#프로토타입-스코프---싱글톤-빈과-함께-사용-시-provider로-문제-해결)
  - [스프링 컨테이너에 요청](#스프링-컨테이너에-요청)
  - [ObjectFactory, ObjectProvider](#objectfactory-objectprovider)
  - [JSR-330 Provider](#jsr-330-provider)
  - [정리](#정리)
- [웹 스코프](#웹-스코프)
- [request 스코프 예제 만들기](#request-스코프-예제-만들기)
- [스코프와 Provider](#스코프와-provider)
- [스코프와 프록시](#스코프와-프록시)

# 빈 스코프란?
> 빈 스코프: 빈이 존재할 수 있는 범위

스프링 빈은 기본적으로 싱글톤 스코프로 생성된다.
- 따라서 스프링 컨테이너가 종료될 때까지 유지

스프링은 아래와 같은 스코프를 지원
- **싱글톤**: 기본 스코프, 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프
- **프로토타입**: 스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입까지만 관여하고 더는 관리하지 않는 매우 짧은 범위의 스코프
  - 종료 메소드 호출이 불가능!
- **웹 관련 스코프**: 스프링 웹과 관련된 기능이 들어가야 사용할 수 있는 스코프
  - **request**: 웹 요청이 들어오고 나갈때 까지 유지되는 스코프
  - **session**: 웹 세션이 생성되고 종료될 때 까지 유지되는 스코프 -> 로그인에서 많이 사용
  - **application**: 웹의 서블릿 컨텍스트와 같은 범위로 유지되는 스코프

**빈 스코프 지정 방법**
- `@Scope("prototype")` 사용

---

# 프로토타입 스코프
프로토타입 스코프를 스프링 컨테이너에 조회하면 스프링 컨테이너는 **항상 새로운 인스턴스를 생성, 의존관계 주입, 초기화해서 반환**

![prototype](./image/prototype.png)
- **요청 시**(`ac.getBean()`)에 프로토타입 빈을 생성하고, 의존관계를 주입, 초기화
- 생성한 빈을 반환

=> 따라서 매번 다른 빈을 반환받게 된다!

> 프로타타입 빈을 관리할 책임은 프로토타입 빈을 받은 클라이언트에 있기에, 스프링 컨테이너가 종료될때, `@PreDestroy` 같은 종료 메소드가 호출되지 않는다.

---

# 프로토타입 스코프 - 싱글톤 빈과 함께 사용 시 문제점
싱글톤 빈과 함께 사용하는 경우, 프로토타입 스코프의 빈이어도 항상 새로운 객체 인스턴스를 생성해서 반환하지 않을 수도 있다.

## 프로토타입 빈 직접 요청
![prob1](./image/prob1.png)
- 프로토타입 빈을 요청해서, 새로 생성된 빈을 반환받았다.
- 그리고 그 빈의 `addCount()`를 호출해, 해당 빈의 `count` 필드 값을 변경했다.

![prob2](./image/prob2.png)
- 다른 클라이언트가 동일한 빈을 요청해서, 새로 생성된 빈을 반환받았다.
- 위 클라이언트와 동일한 작업을 수행했다.

## 싱글톤 빈에서 프로토타입 빈 사용
`clientBean` 이라는 싱글톤 빈이 의존관계 주입을 통해 프로토타입 빈을 주입받는 상황을 가정해보자.

![prob3](./image/prob3.png)
- `clientBean` 은 컨테이너 생성 시점에 이미 빈이 생성되었다.
- 그리고 이때, **의존 관계가 있는 프로토타입 빈을 생성해서 주입**받았다.
- 이후 `clientBean` 은 **프로토타입 빈의 참조값**을 내부 필드로서 관리한다.

![prob5](./image/prob5.png)
- 클라이언트 A가 `clientBean` 을 요청해 컨테이너로부터 받는다.
- 이후 A가 `clientBean.logic()`을 호출하고, 해당 로직은 prototypeBean의 `addCount()`를 호출한다.
  - 이제 `prototypeBean` 의 `count` 는 1이다.

![prob6](./image/prob6.png)
- 클라이언트 B가 A와 동일한 로직을 수행하고, 결과적으로 `prototypeBean` 의 `count` 는 2이다.

> 중요한 점은, `prototypeBean` 은 여기서 실제로 프로토타입 스코프를 가지고 있지 않다는 것이다.
> - 이미 과거에 주입이 끝났고, 사용할 때마다 새로 생성이 되는 것이 아니다!!!

스프링은 싱글톤 빈을 일반적으로 사용하기에, 싱글톤 빈이 프로토타입 빈을 사용하게 될 것이다. 프로토타입 빈은 싱글톤 빈과 함께 유지되어, 사용할 때마다 새로 생성되지는 않을 것이다.

---

# 프로토타입 스코프 - 싱글톤 빈과 함께 사용 시 Provider로 문제 해결
그럼 어떻게 하면 싱글톤 빈과 함께 사용하면서 프로토타입 빈을 매 요청마다 새로 생성해서 사용할 수 있을까?

## 스프링 컨테이너에 요청
가장 간단한 방법은 싱글톤 빈이 프로토타입을 사용할 때마다, 컨테이너에 새로 요청하는 방식이다.

```java
public int logic() {
  PrototypeBean prototypeBean = ac.getBean(PrototypeBean.class);
  prototypeBean.addCount();
  int count = prototypeBean.getCount();
  return count;
}
```

- 위와 같이 의존 관계를 외부에서 주입받는 게 아닌, 직접 찾는 것을 **의존 관계 탐색(조회), Dependency Lookup(DL)** 이라 한다.
- 이러한 코드는 스프링 컨테이너에 종속적인 코드가 되고, 단위 테스트 또한 어렵게 한다.

=> 즉, 이 방법은 우리가 필요로 하는, "지정한 프로토타입 빈을 컨테이너에서 대신 찾아주는 정도의 기능"만 제공하지는 않고 있다.

## ObjectFactory, ObjectProvider
우리가 필요로 하는 DL 서비스를 제공하는 것이 `ObjectProvider` 이다.
- 기존의 `ObjectFactory` 를 상속하고, 옵션, 스트림 처리 등의 편의 기능이 추가되고, 별도의 라이브러리가 필요하지 않은 클래스

```java
@Autowired
private ObjectProvider<PrototypeBean> prototypeBeanProvider;

public int logic() {
    PrototypeBean prototypeBean = prototypeBeanProvider.getObject();
    prototypeBean.addCount();
    int count = prototypeBean.getCount();
    return count;
}
```

- `getObject()`를 호출하면, 컨테이너로부터 제네릭으로 전달된 `PrototypeBean` 타입의 빈을 요청한다.
- 딱 필요한 **DL** 정도의 기능만을 제공한다.

> 하지만 이 방식은 **스프링에 의존**한다는 문제점이 있다.

## JSR-330 Provider
마지막 방법은 `javax.inject.Provider` 라는 JSR-330 **자바 표준**을 사용하는 방법이다.
- 말 그대로 자바 표준을 사용하기에, 위에서의 문제점이었던 스프링에 대한 의존성을 없앨 수 있다.
- 라이브러리 추가는 필요하다!

```java
// implementation 'javax.inject:javax.inject:1' gradle 추가 필수

@Autowired 
private Provider<PrototypeBean> provider;

public int logic() {
      PrototypeBean prototypeBean = provider.get();
      prototypeBean.addCount();
      int count = prototypeBean.getCount();
      return count;
}
```

> 지연 로딩이나, 순환 참조 시에 이를 활용할 수 있다!!!

## 정리
- 실무에서는 싱글톤 빈으로 대부분의 문제를 해결하기에, 프로토타입 빈을 사용하는 경우는 드물다.

---

# 웹 스코프
**웹 스코프의 특징**
- 웹 환경에서만 동작
- 스프링이 해당 스코프의 종료 시점까지 관리한다. 따라서 종료 메소드가 호출된다. (프로토타입은 그렇지 않았다.)

**웹 스코프 종류**
- **request**: **HTTP 요청 하나**가 들어오고 나갈 때까지 유지되는 스코프, 각각의 HTTP 요청마다 별도의 빈 인스턴스가 생성되고, 관리된다.
- **session**: HTTP Session과 동일한 생명주기를 가지는 스코프
- **application**: 서블릿 컨텍스트( `ServletContext` )와 동일한 생명주기를 가지는 스코프
- **websocket**: 웹 소켓과 동일한 생명주기를 가지는 스코프

**HTTP request 요청당 각각 할당되는 request 웹 스코프**
![requestScope](./image/requestScope.png)

---

# request 스코프 예제 만들기

---

# 스코프와 Provider

---

# 스코프와 프록시
