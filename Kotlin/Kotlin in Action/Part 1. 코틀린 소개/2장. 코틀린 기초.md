**다룰 내용**
- 함수, 변수, 클래스, enum, 프로퍼티 선언 방법
- 제어 구조
- 스마트 캐스트
- 예외 던지기와 잡기

**TOC**
- []()

---
# 기본 요소: 함수와 변수
## Hello, World!
```kotlin
fun main(args: Array<String>) {
    println("Hello World!")
}
```
- 함수 선언 시 `fun` 키워드를 사용한다.
- 파라미터 이름 뒤에, 파라미터의 타입이 명시된다. 변수에도 마찬가지이다.
- 함수를 최상위 수준에 정의할 수 있다.
  - 꼭 클래스 안에 없어도 된다.
- 배열도 일반 클래스와 마찬가지이다. 배열 처리를 위한 문법이 존재하지 않는다.
- 코틀린 표준 라이브러리는 여러 자바 표준 라이브러리 함수를 간결하게 사용할 수 있도록 감싼 Wrapper를 제공한다.
  - `println()`
- 노 세미콜론!

## 함수
위 예제는 반환값이 없는 함수였다.
- 반환값이 있는 함수의 경우는 다음과 같이 선언한다.

```kotlin
fun max(a: Int, b: Int): Int {
    return if (a > b) a else b
}

fun main() {
	println(max(1, 2))
}
```
- 함수의 반환 타입은 파라미터 목록 괄호 이후에 `:` 로 구분되어 명시된다.
- 코틀린에서 `if` 는 결과를 만드는 식이라는 점이 자바와 다르다. (자바는 식이 아니라 문(statement)이다.)
  - 위 코드는 자바의 `(a > b) ? a : b` 와 유사하다.

> **문과 식의 구분**
> - 식은 값을 만들어내며, 다른 식의 하위 요소로 게산에 참여할 수 있다.
> - 문은 자신을 둘러싼 가장 안쪽 블록의 최상위 요소로 존재하며 아무런 값을 만들어내지 않는다.

### 식이 본문인 함수
위 예제를 좀 더 간결하게 표현할 수 있다.
- 위 예제에서 함수 본문은 if 식 하나로 이뤄져 있는데, 이런 경우 아래와 같이 변환할 수 있다.

```kotlin
fun max(a: Int, b: Int): Int = if (a > b) a else b
```

- 본문이 중괄호로 둘러싸인 함수 = 블록이 본문인 함수
- 등호와 식으로 이뤄진 함수 = 식이 본문인 함수

또한 위 코드에서는 반환형까지 제거할 수 있는데, 이는 **식이 본문인 함수의 경우에만 가능**하다.
- 코틀린 컴파일러가 함수 본문 식을 분석해, 식의 결과 타입을 함수 반환 타입으로 정해준다.
- 이를 **타입 추론**이라 한다.

> 함수 반환형 타입 추론은 식이 본문인 함수의 경우만 가능.

## 변수
코틀린에서는 타입 지정을 생략하는 경우가 흔하고, 이런 경우 식과 변수 선언을 구별하기 위해, **변수 이름 뒤에 타입을 명시하거나 생략**하도록 한다.

아까 위에서 다룬 타입 추론이 여기서도 사용된다.
- 초기화 식을 토대로 컴파일러가 타입을 추론한다.
- 따라서 **초기화 식이 있는 경우에만 타입 생략이 가능**하다.

### 변경 가능한 변수와 변경 불가능한 변수
변수 선언 시 사용하는 키워드
- `val(value)` : 변경 불가능한 참조를 저장하는 변수.
  - 재할당 불가능하고, 자바의 final에 해당.
- `var(variable)` : 변경 가능한 참조를 저장하는 변수.
  - 재할당 가능하고, 자바의 일반 변수에 해당.

> 기본적으로는 모든 변수를 `val` 키워드를 사용해 불변 변수로 선언하고, 나중에 꼭 필요할 때만 `var` 로 변경하라.
> - 변경 불가능한 참조와 변경 불가능한 객체를 부수 효과가 없는 함수와 조합해 사용하면 함수형 코드에 가까워진다.
> - 순수 함수를 만들어낼 수 있어서 그런 걸까?

val 변수는 블록 실행 시 오직 한 번만 실행되어야 한다.
- 하지만 어떤 블록이 실행될 때, 오직 한 초기화 문장으로만 실행됨을 컴파일러가 알 수 있다면, 조건에 따라 여러 값으로 초기화할 수 있다.

```kotlin
val message: String
if (canPerformSomething()) {
    message = "Success"
} else {
    message = "Failed"
}
```

`var` 변수는 값을 재할당할 수는 있지만, 그 타입은 고정되어 바뀌지 않는다.
```kotlin
var answer = 42
answer = "no answer" // 컴파일 오류
```
- 재할당되는 타입이 컴파일러가 기대하는 타입과 달라서, 컴파일 오류가 발생한다.
- 컴파일러는, 변수 선언 시점의 초기화 식으로부터 변수의 타입을 추론하기 때문에, 이후의 재할당에서 해당 타입으로 검사한다.

만약 다른 타입의 값을 저장하고 싶다면,
- 변환 함수를 통해 값을 변수의 타입으로 변환하거나,
- 값을 변수에 대입할 수 있는 타입으로 강제 형 변환해야 한다.

## 더 쉽게 문자열 형식 지정: 문자열 템플릿