**다룰 내용**
- 함수, 변수, 클래스, enum, 프로퍼티 선언 방법
- 제어 구조
- 스마트 캐스트
- 예외 던지기와 잡기

**TOC**
- [기본 요소: 함수와 변수](#기본-요소-함수와-변수)
  - [Hello, World!](#hello-world)
  - [함수](#함수)
    - [식이 본문인 함수](#식이-본문인-함수)
  - [변수](#변수)
    - [변경 가능한 변수와 변경 불가능한 변수](#변경-가능한-변수와-변경-불가능한-변수)
  - [더 쉽게 문자열 형식 지정: 문자열 템플릿](#더-쉽게-문자열-형식-지정-문자열-템플릿)
- [클래스와 프로퍼티](#클래스와-프로퍼티)
  - [프로퍼티](#프로퍼티)
  - [커스텀 접근자](#커스텀-접근자)
  - [코틀린 소스코드 구조: 디렉토리와 패키지](#코틀린-소스코드-구조-디렉토리와-패키지)
- [선택 표현과 처리: enum과 when](#선택-표현과-처리-enum과-when)
  - [enum 클래스 정의](#enum-클래스-정의)
  - [when으로 enum 클래스 다루기](#when으로-enum-클래스-다루기)
  - [when과 임의의 객체를 함께 사용](#when과-임의의-객체를-함께-사용)

---
# 기본 요소: 함수와 변수
## Hello, World!
```kotlin
fun main(args: Array<String>) {
    println("Hello World!")
}
```
- 함수 선언 시 `fun` 키워드를 사용한다.
- 파라미터 이름 뒤에, 파라미터의 타입이 명시된다. 변수에도 마찬가지이다.
- 함수를 최상위 수준에 정의할 수 있다.
  - 꼭 클래스 안에 없어도 된다.
- 배열도 일반 클래스와 마찬가지이다. 배열 처리를 위한 문법이 존재하지 않는다.
- 코틀린 표준 라이브러리는 여러 자바 표준 라이브러리 함수를 간결하게 사용할 수 있도록 감싼 Wrapper를 제공한다.
  - `println()`
- 노 세미콜론!

## 함수
위 예제는 반환값이 없는 함수였다.
- 반환값이 있는 함수의 경우는 다음과 같이 선언한다.

```kotlin
fun max(a: Int, b: Int): Int {
    return if (a > b) a else b
}

fun main() {
	println(max(1, 2))
}
```
- 함수의 반환 타입은 파라미터 목록 괄호 이후에 `:` 로 구분되어 명시된다.
- 코틀린에서 `if` 는 결과를 만드는 식이라는 점이 자바와 다르다. (자바는 식이 아니라 문(statement)이다.)
  - 위 코드는 자바의 `(a > b) ? a : b` 와 유사하다.

> **문과 식의 구분**
> - 식은 값을 만들어내며, 다른 식의 하위 요소로 게산에 참여할 수 있다.
> - 문은 자신을 둘러싼 가장 안쪽 블록의 최상위 요소로 존재하며 아무런 값을 만들어내지 않는다.

### 식이 본문인 함수
위 예제를 좀 더 간결하게 표현할 수 있다.
- 위 예제에서 함수 본문은 if 식 하나로 이뤄져 있는데, 이런 경우 아래와 같이 변환할 수 있다.

```kotlin
fun max(a: Int, b: Int): Int = if (a > b) a else b
```

- 본문이 중괄호로 둘러싸인 함수 = 블록이 본문인 함수
- 등호와 식으로 이뤄진 함수 = 식이 본문인 함수

또한 위 코드에서는 반환형까지 제거할 수 있는데, 이는 **식이 본문인 함수의 경우에만 가능**하다.
- 코틀린 컴파일러가 함수 본문 식을 분석해, 식의 결과 타입을 함수 반환 타입으로 정해준다.
- 이를 **타입 추론**이라 한다.

> 함수 반환형 타입 추론은 식이 본문인 함수의 경우만 가능.

## 변수
코틀린에서는 타입 지정을 생략하는 경우가 흔하고, 이런 경우 식과 변수 선언을 구별하기 위해, **변수 이름 뒤에 타입을 명시하거나 생략**하도록 한다.

아까 위에서 다룬 타입 추론이 여기서도 사용된다.
- 초기화 식을 토대로 컴파일러가 타입을 추론한다.
- 따라서 **초기화 식이 있는 경우에만 타입 생략이 가능**하다.

### 변경 가능한 변수와 변경 불가능한 변수
변수 선언 시 사용하는 키워드
- `val(value)` : 변경 불가능한 참조를 저장하는 변수.
  - 재할당 불가능하고, 자바의 final에 해당.
- `var(variable)` : 변경 가능한 참조를 저장하는 변수.
  - 재할당 가능하고, 자바의 일반 변수에 해당.

> 기본적으로는 모든 변수를 `val` 키워드를 사용해 불변 변수로 선언하고, 나중에 꼭 필요할 때만 `var` 로 변경하라.
> - 변경 불가능한 참조와 변경 불가능한 객체를 부수 효과가 없는 함수와 조합해 사용하면 함수형 코드에 가까워진다.
> - 순수 함수를 만들어낼 수 있어서 그런 걸까?

val 변수는 블록 실행 시 오직 한 번만 실행되어야 한다.
- 하지만 어떤 블록이 실행될 때, 오직 한 초기화 문장으로만 실행됨을 컴파일러가 알 수 있다면, 조건에 따라 여러 값으로 초기화할 수 있다.

```kotlin
val message: String
if (canPerformSomething()) {
    message = "Success"
} else {
    message = "Failed"
}
```

`var` 변수는 값을 재할당할 수는 있지만, 그 타입은 고정되어 바뀌지 않는다.
```kotlin
var answer = 42
answer = "no answer" // 컴파일 오류
```
- 재할당되는 타입이 컴파일러가 기대하는 타입과 달라서, 컴파일 오류가 발생한다.
- 컴파일러는, 변수 선언 시점의 초기화 식으로부터 변수의 타입을 추론하기 때문에, 이후의 재할당에서 해당 타입으로 검사한다.

만약 다른 타입의 값을 저장하고 싶다면,
- 변환 함수를 통해 값을 변수의 타입으로 변환하거나,
- 값을 변수에 대입할 수 있는 타입으로 강제 형 변환해야 한다.

## 더 쉽게 문자열 형식 지정: 문자열 템플릿
```kotlin
fun main(args: Array<String>) {
    val name = if (args.size > 0) args[0] else "Kotlin"
    println("Hello, $name!")
}
```
- 인자로 넘긴 값이 있으면 그 값을 출력하고, 그렇지 않으면 `"Kotlin"` 을 출력

여기서 **문자열 템플릿**이라는 기능이 사용된다.
- 문자열 리터럴 안에서 `name` 이라는 변수를 사용하고 있다.
- 이와 같이 `$ + 변수` 를 문자열 안에서 사용하는 것을 문자열 템플릿이라 한다.
  - 복잡한 식의 경우 중괄호로 감싸서 사용할 수 있다.
  - 중괄호 안에서 큰 따옴표를 사용할 수도 있다.

> $ 문자 자체를 출력하고 싶은 경우, 앞에 이스케이프 문자(`\`)를 붙이면 된다.

# 클래스와 프로퍼티
먼저 자바빈 클래스를 하나 생성한다.

```java
public class Person {
    private final String name;

    public Person(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }
}
```
- 현재는 필드가 하나이지만, 필드가 늘어나면, 생성자의 본문에 파라미터를 이름이 같은 필드에 대입하는 대입문의 수가 늘어난다.
- 코틀린에서는 이러한 반복적인 대입 로직을 더 적은 코드로 수행한다.

```kotlin
class Person(val name: String)
```
- 한 줄의 코드로 변환되었다.
- 이런 유형의 클래스(코드 없이 데이터만 저장하는 클래스)를 **값 객체(value object)**라고 한다.
- 코틀린의 기본 가시성(접근 제한)은 `public` 이다.
  - 따라서 위 코드에서 생략됨.

## 프로퍼티
> 클래스의 목적: 데이터를 캡슐화하고, 캡슐화한 데이터를 다루는 코드를 한 주체 아래 가두는 것이다.

자바에서는 데이터를 필드에 저장하고, 보통 `private` 접근자를 사용한다.
- 그리고 **접근자 메소드**를 통해 데이터에 접근하는 통로를 제공한다.
- 필드와 접근자를 **프로퍼티**라고 부르며, 이를 활용하는 프레임워크가 많다.

코틀린에서는 조금 다르다.
- 프로퍼티를 언어 기본 기능으로 제공하며,
- **자바의 필드와 접근자 메소드**를 완전히 대신한다.

```kotlin
class Person (
    val name: String.
    var isMarried: Boolean
)
```
- `val` : 읽기 전용, `private` 필드와 `getter` 자동 제공
- `var` : 읽기, 쓰기 가능, `private` 필드와 `getter` & `setter` 자동 제공
- 위 코드는 생성자를 통해 두 필드를 초기화하고, 두 필드 모두 `getter` 를 통해 접근할 수 있다.
  - 또한 `isMarried` 의 경우, `setter` 를 통해 값을 변경할 수 있다.

해당 클래스를 사용하는 코드는 자바던, 코틀린이던 동일하지만 조금의 차이점은, `getter` 와 `setter` 의 네이밍 규칙이다.
- 이름이 `is` 로 시작하는 프로퍼티의 `getter` 에는 `get` 이 붙지 않고, 원래 이름을 그대로 사용한다. (ex. `isMarried` -> `isMarried()`)
- `setter` 에는 `is` 를 `set` 으로 바꾼 이름을 사용한다. (ex. `isMarried` -> `setMarried()`)

```kotlin
val person = Person("Bob", true)

println(person.name) // Bob

println(person.isMarried) // true

person.isMarried = false
```
- 위와 같이 코틀린에서는 또한, `getter` 를 호출하는 대신 프로퍼티를 직접 사용할 수 있다.
  - 위 코드는 코틀린이 자동으로 `getter` 를 호출하도록 한다.
- `setter` 또한 프로퍼티를 통해 호출 가능하다.

대부분의 프로퍼티에는 그 프로퍼티 값을 저장하기 위한 필드가 있다.
- 이를 **프로퍼티를 뒷받침하는 필드**, `backing field` 라고 한다.
- 다음 절에서는 **커스텀 getter** 를 통해 프로퍼티 값을 그때마다 계산하는 방법을 제공한다.

## 커스텀 접근자
직사각형 클래스(`Rectangle`)를 정의하면서, 자신이 정사각형인지 알려주는 기능을 만들어본다.
- 정사각형 여부를 필드에 저장하지 않고, 사각형의 높이와 너비를 검사해 정사각형 여부를 그때그때 판단한다.

```kotlin
class Rectangle(val height: Int, val width: Int) {
    val isSquare: Boolean
        get() {
            return height == width
        }
}
```
- `isSquare` : 자체 값을 저장하는 필드가 필요없다. 대신 자체 구현을 제공하는 getter만 존재한다.
  - 이 프로퍼티에 접근할 때마다, getter가 매번 프로퍼티 값을 재계산한다.

> 파라미터가 없는 함수와 커스텀 getter는 가독성 외의 차이는 없다. 의미상으로, 클래스의 특성(프로퍼티)를 정의하고 싶은 경우는 커스텀 getter를 사용할 수 있다.

> 생성자를 통해 바로 이러한 정보를 저장해도 되지 않을까. 만약 매번 값이 바뀔 수 있는 경우가 아니라면 그 방식이 불필요한 계산을 줄일 수 있을 것 같다.

## 코틀린 소스코드 구조: 디렉토리와 패키지
자바의 경우, 모든 클래스를 패키지 단위로 관리한다.
- 코틀린에서도, 이와 비슷한 패키지의 개념을 사용한다.
- package 문으로 그 파일의 모든 선언(클래스, 함수, 프로퍼티 등)을 해당 패키지에 포함시킨다.
- 같은 패키지의 경우, 다른 파일의 선언이라도 사용할 수 있고, 다른 패키지의 경우라면 `import` 를 통해 불러와야 한다.
- 조금 다른 점은, 
  - 클래스 import와 함수 import에 차이가 없다.
  - 모든 선언을 `import` 로 가져올 수 있다.
  - 최상위 함수는 그 이름을 통해 import할 수 있다.

자바에서는 패키지와 디렉토리 구조를 동일하게 가져간다.
- `geometry.example` 이라는 패키지가 있다면, `geometry` 디렉토리를 만들고 그 안에 `example` 이라는 디렉토리를 만들고 클래스들을 위치시킨다.

하지만 코틀린의 경우, 소스코드 구성에 있어 조금 더 자유롭다.
- `geometry.example` 이라는 패키지가 있다면, 그 패키지의 모든 내용을 `example.kt` 파일에 넣고, `geometry` 라는 디렉토리에 위치시켜도 된다.

> 하지만, 대부분의 경우 자바의 방식을 따르는 것이 낫다. 직관적이기도 하고, 협업 시에 오히려 더 헷갈릴 수 있을 것 같다.

# 선택 표현과 처리: enum과 when
## enum 클래스 정의
색을 표현하는 enum을 하나 정의한다.
```kotlin
enum class Color {
    RED, ORANGE, YELLOW, GREEN, BLUE, INDIGO, VIOLET
}
```
- 코틀린에서 `enum` 은 **소프트 키워드**라 부르는 존재다.
  - `class` 앞에 있을 때는 특별한 의미를 가지지만, 다른 곳에서는 이름으로 사용할 수 있다. (다른 예약어처럼 사용이 불가한 것이 아니다!)
  - 반면, `class` 는 키워드이므로 예약어이다.

자바와 마찬가지로, `enum` 클래스 안에 프로퍼티나 메소드를 정의할 수 있다.

```kotlin
enum class Color(
    val r: Int,
    val g: Int,
    val b: Int
) {
    RED(255, 0, 0),
    ORANGE(255, 165, 0),
    YELLOW(255, 255, 0),
    GREEN(0, 255, 0),
    BLUE(0, 0, 255),
    INDIGO(75, 0, 130),
    VIOLET(238, 130, 228);

    fun rgb() = (r * 256 + g) * 256 + b
}
```

## when으로 enum 클래스 다루기
자바의 `switch` 에 해당하는 코틀린의 제어자는 `when` 이다.
- 이또한 `if` 와 마찬가지로, **값을 만들어내는 식**이다.
- 따라서 식이 본문인 함수에 `when` 을 바로 사용할 수 있다.

```kotlin
fun getMnemonic(color: Color) =
    when (color) {
        RED -> "Richard"
        ORANGE -> "Of"
        YELLOW -> "York"
        GREEN -> "Gave"
        BLUE -> "Battle"
        INDIGO -> "In"
        VIOLET -> "Vain"
    }
```
- `color` 로 전달된 값과 같은 분기를 찾아 그 분기를 실행한다.
- `INDIGO, VIOLET -> "In Vain"` 처럼 콤마를 사용해 한 분기에서 여러 값을 매치 패턴으로 사용할 수도 있다.

## when과 임의의 객체를 함께 사용
코틀린의 `when` 은 자바의 `switch` 보다 더 강력하다.
- 위에 언급된 것처럼, 코틀린의 `when` 은 임의의 객체를 허용한다.

```kotlin
fun mix(c1: Color, c2: Color) =
    when (setOf(c1, c2)) {
        setOf(RED, YELLOW) -> ORANGE
        setOf(YELLOW, BLUE) -> GREEN
        setOf(BLUE, VIOLET) -> INDIGO
        else -> throw Exception("Dirty Color")
    }
```
- 전달된 두 색의 혼합된 결과를 반환하는 함수이다.
- 이때 비교를 위해 집합 비교를 사용
  - `setOf()` : 여러 객체를 그 객체들을 포함하는 집합인 `Set` 으로 생성
