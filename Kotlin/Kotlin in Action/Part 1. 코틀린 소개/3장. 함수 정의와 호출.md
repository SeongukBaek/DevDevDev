**다룰 내용**
- 컬렉션, 문자열, 정규식을 다루기 위한 함수
- 이름 붙인 인자, 디폴트 파라미터 값, 중위 호출 문법 사용
- 확장 함수와 확장 프로퍼티를 사용해 자바 라이브러리 적용
- 최상위 및 로컬 함수와 프로퍼티를 사용해 코드 구조화

**TOC**

# 코틀린에서 컬렉션 만들기
컬렉션 생성 : hashSetOf(), setOf(), arrayListOf(), hashMapOf(), ...

> setOf(): 불변 Set 생성

```kotlin
val map = hashMapOf(1 to "one", 7 to "seven", 53 to "fifty-three")
print(map)

// {1=one, 53=fifty-three, 7=seven}
```
- to : 일반 함수.
- 위에서 언급된 컬렉션 생성 함수들이 만드는 결과물의 타입은 모두 자바의 컬렉션 클래스이다.
  - 즉, 코틀린이 자신만의 컬렉션 기능을 제공하지 않는다. **자바의 컬렉션을 활용한다.**
  - 이또한 자바와의 상호 운용성을 위함이지 않을까.
 
코틀린은 자바보다 더 많은 컬렉션의 기능을 제공한다.
- ex. 리스트의 마지막 원소 반환 (`list.last()`), 수로 이뤄진 컬렉션의 최댓값 반환 (`set.max()`)

# 함수를 호출하기 쉽게 만들기
자바의 경우, 기본 구현된 toString() 을 통해 컬렉션의 원소를 출력할 수 있지만, 이는 고정된 형태이다.
원하는 형태로 출력 양식을 지정하기 위해서는 구아바나 아파치 커먼즈 같은 서드파티 프로젝트를 추가하거나, 직접 구현해야 한다.

> **코틀린은 이를 처리하는 함수가 표준 라이브러리에 포함되어 있다.**

코틀린으로, 이를 처리하는 함수를 직접 작성하고, 이후 코틀린이 지원하는 기능을 사용해서 구현한다.

```kotlin
// 제네릭한 함수, joinToString(listOf(1, 2, 3), "; ", "(", ")") => (1; 2; 3)
fun <T> joinToString(collection: Collection<T>, separator: String, prefix: String, postfix: String): String {
    val result = StringBuilder(prefix)
    
    for ((index, element) in collection.withIndex()) {
		if (index > 0) result.append(separator)
        result.append(element)
	}
    
    result.append(postfix)
    return result.toString()
}
```
이제 위 코드를 조금씩 개선한다.

## 이름 붙인 인자
함수 호출 부분의 가독성을 개선한다.
- 인자로 전달된 각 문자열들의 역할이 모호해보인다.
- 코틀린에서는 **함수에 전달하는 인자 중 일부 또는 전부의 이름을 명시할 수 있다.** 이를 통해 메소드만 봤을 때 오는 모호함을 줄일 수 있다.

```kotlin
joinToString(listOf(1, 2, 3), separator = "; ", prefix = "(", postfix = ")")
```

## 디폴트 파라미터 값
자바의 경우, 일부 클래스에서 오버로딩한 메소드가 너무 많아지는 문제가 발생하곤 한다.
- 너무 많은 생성자 등 ..
- 이는 많은 중복 코드를 낳고, 많은 설명을 요구한다.

코틀린에서는 디폴트 파라미터 값을 지정할 수 있어, 오버로드 상당수를 피할 수 있다.

```kotlin
fun <T> joinToString(
    collection: Collection<T>, 
    separator: String = "; ", 
    prefix: String = "(", 
    postfix: String = ")"
): String {
  // something
}
```

### 정적 유틸 클래스 제거: 최상위 함수와 프로퍼티
자바에서는 정적 유틸 클래스를 통해, 다양한 정적 메소드를 모아두는 클래스를 생성해서 사용하곤 한다.
- 어찌보면 클래스로서는 무의미하다고 할 수 있다. 인스턴스를 생성하지 않는 클래스이기 때문에 ?
- 코틀린에서는 **함수를 소스 파일의 최상위 수준, 모든 다른 클래스의 밖에 위치시키면 된다.**
  - 다른 패키지에서 사용하려면 임포트 필요.
 
```kotlin
// join.kt
package strings

fun joinToString(...): String { ... }
```
- 위 파일을 컴파일하면, 다음과 같은 자바 파일이 생성된다고 보면 된다.

```java
package strings;

public class JoinKt {
    public static String joinToString(...) { ... }
}
```
- 여기서 코틀린 파일명으로 클래스가 생성되었는데, 클래스명을 지정하고 싶다면 `@file:JvmName` 어노테이션으로 지정할 수 있다.

프로퍼티 또한 함수처럼 최상위에 위치시킬 수 있다.
- val, var 키워드로 명시하고, 키워드에 맞는 getter, setter 자동 생성
- 상수를 위와 같이 선언하면, 접근 시에 getter 를 써야하는 것이 어색하기 때문에, `const` 키워드를 통해 `public static final` 필드로 만들 수 있다.

## 메소드를 다른 클래스에 추가: 확장 함수와 확장 프로퍼티
