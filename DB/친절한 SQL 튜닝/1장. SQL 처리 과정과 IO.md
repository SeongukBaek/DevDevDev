# SQL 파싱과 최적화
## 구조적, 집합적, 선언적 질의 언어
SQL => '구조적', '집합적', '선언적'
- 하지만, 결과 생성 과정은 **절차적**일 수 밖에 없다.
- 이를 위해서는 '프로시저' 필요 (프로시저 : 특정 작업을 수행하기 위해 일련의 명령어들을 모아놓은 것)
- 그리고 이 프로시저를 만드는 DBMS 내부 엔진이 **SQL 옵티마이저**

## SQL 최적화
> SQL 최적화 : 프로시저를 만들고, 컴파일해서, 실행 가능한 상태로 만드는 것 (ex. 자바 빌드)

1. 파싱
    - 트리 생성: 개벌 구성요소 분석 후 트리 생성
    - Syntax 체크: 사용할 수 없는 키워드? 순서 오류? 키워드 누락?
    - Semantic 체크: 존재하는 테이블? 권한 보유?
2. 최적화
    - 수집한 정보 바탕으로 다양한 실행경로 생성 후, 비교해서 효율적인 하나 채택
3. 로우 소스 생성
    - 프로시저 형태로 포맷팅
  
## SQL 옵티마이저
- 파싱 트리 생성
- 실행계획 예상 비용 산정 <- 오브젝트 통계 및 시스템 통계정보가 비용 책정에 사용
- 최저 비용 선택

## 실행계획과 비용
실행계획을 어떻게 확인할까 (mysql 기준)
- explain: 통계정보를 기반으로 유추
- explain analyze (8.0.18 버전 이상): 실제 쿼리를 실행한 결과

<img width="614" alt="스크린샷 2024-08-13 20 10 04" src="https://github.com/user-attachments/assets/d04c73af-84ee-42f3-8015-033ea66082a8">
<img width="491" alt="스크린샷 2024-08-13 20 10 33" src="https://github.com/user-attachments/assets/4e2eceb2-16e3-41d5-89f4-05253f686c22">

## 옵티마이저 힌트
옵티마이저가 판단한 최적화 방식이 아니라, 개발자의 판단을 따라 수행할 수 있도록 지정해주는 것.

```sql
SELECT /*+ INDEX(post user_id_idx)
  user_id, name
from post
where user_id = '1234';
```

# SQL 공유 및 재사용
## 소프트 파싱 vs. 하드 파싱
**라이브러리 캐시**: 최적화 과정을 통해 생성된 프로시저를 캐싱하는 메모리 공간
- System Global Area 의 구성 요소

**소프트 파싱** : 사용자가 전달한 SQL이 라이브러리 캐시에 존재해서, 바로 실행되는 것
**하드 파싱** : 사용자가 전달한 SQL이 라이브러리 캐시에 존재하지 않아서, 최적화과정을 통해 프로시저를 새로 생성하는 것

그럼 왜 라이브러리 캐시를 통해 SQL 프로시저를 캐싱할까?
- ex. 자동차 내비게이션
- 주어진 SQL를 수행하는데 후보군이 될 만한 많은 실행 경로를 도출하고, 각각의 효율성을 판단하는 것은 매우 고연산이 필요한 작업.
- 이렇게 어려운 작업을 거쳐서 생성된 프로시저를 일회성으로 사용한다면 매우 비효율적.

## 바인드 변수의 중요성
**이름 없는 SQL 문제**
SQL이 프로시저나 트리거, 패키지처럼 저장되지 않는 이유는 뭘까? (물론 저장하는 DBMS도 있긴 함.)
- SQL은 그 자체가 이름이고 식별자
- 따라서 매 수정마다 새로운 객체가 생성되는 꼴.
- 특히 개발 단계에서는 일회성 SQL을 많이 사용하게 되는데, 이때마다 SQL을 저장한다면 매우 비효율적.

**공유 가능 SQL**
SQL은 그 자체가 이름. -> 같은 로직을 수행하는 SQL들이더라도, 텍스트가 다르면 매번 새로 최적화되고, 라이브러리 캐시에 캐싱.

```sql
SELECT * FROM CUSTOMER WHERE LOGIN_ID = '" + login_id + "';
```
- 만약 위와 같은 SQL이 있고, 특정 이벤트나 프로모션으로 인해, 한 순간 로그인 유저가 몰리는 경우, CPU는 로그인 유저 당 1개의 내부 프로시저를 만드느라 펑!

그럼 로그인 유저 당 1개의 프로시저가 아니라, 로그인 유저를 파라미터로 받는 프로시저가 1개 생성된다면 모두 처리 가능할 것
- 이를 위해 **바인드 변수**가 필요.

```sql
SELECT * FROM CUSTOMER WHERE LOGIN_ID = ?;
```

# 데이터 저장 구조 및 I/O 메커니즘
I/O 튜닝 == SQL 튜닝
