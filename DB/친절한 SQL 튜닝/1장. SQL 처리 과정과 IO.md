# SQL 파싱과 최적화
## 구조적, 집합적, 선언적 질의 언어
SQL => '구조적', '집합적', '선언적'
- 하지만, 결과 생성 과정은 **절차적**일 수 밖에 없다.
- 이를 위해서는 '프로시저' 필요 (프로시저 : 특정 작업을 수행하기 위해 일련의 명령어들을 모아놓은 것)
- 그리고 이 프로시저를 만드는 DBMS 내부 엔진이 **SQL 옵티마이저**

## SQL 최적화
> SQL 최적화 : 프로시저를 만들고, 컴파일해서, 실행 가능한 상태로 만드는 것 (ex. 자바 빌드)

1. 파싱
    - 트리 생성: 개벌 구성요소 분석 후 트리 생성
    - Syntax 체크: 사용할 수 없는 키워드? 순서 오류? 키워드 누락?
    - Semantic 체크: 존재하는 테이블? 권한 보유?
2. 최적화
    - 수집한 정보 바탕으로 다양한 실행경로 생성 후, 비교해서 효율적인 하나 채택
3. 로우 소스 생성
    - 프로시저 형태로 포맷팅
  
## SQL 옵티마이저
- 파싱 트리 생성
- 실행계획 예상 비용 산정 <- 오브젝트 통계 및 시스템 통계정보가 비용 책정에 사용
- 최저 비용 선택

## 실행계획과 비용
실행계획을 어떻게 확인할까 (mysql 기준)
- explain: 통계정보를 기반으로 유추
- explain analyze (8.0.18 버전 이상): 실제 쿼리를 실행한 결과

<img width="614" alt="스크린샷 2024-08-13 20 10 04" src="https://github.com/user-attachments/assets/d04c73af-84ee-42f3-8015-033ea66082a8">
<img width="491" alt="스크린샷 2024-08-13 20 10 33" src="https://github.com/user-attachments/assets/4e2eceb2-16e3-41d5-89f4-05253f686c22">

## 옵티마이저 힌트
옵티마이저가 판단한 최적화 방식이 아니라, 개발자의 판단을 따라 수행할 수 있도록 지정해주는 것.

```sql
SELECT /*+ INDEX(post user_id_idx)
  user_id, name
from post
where user_id = '1234';
```

# SQL 공유 및 재사용
## 소프트 파싱 vs. 하드 파싱
**라이브러리 캐시**: 최적화 과정을 통해 생성된 프로시저를 캐싱하는 메모리 공간
- System Global Area 의 구성 요소

**소프트 파싱** : 사용자가 전달한 SQL이 라이브러리 캐시에 존재해서, 바로 실행되는 것
**하드 파싱** : 사용자가 전달한 SQL이 라이브러리 캐시에 존재하지 않아서, 최적화과정을 통해 프로시저를 새로 생성하는 것

그럼 왜 라이브러리 캐시를 통해 SQL 프로시저를 캐싱할까?
- ex. 자동차 내비게이션
- 주어진 SQL를 수행하는데 후보군이 될 만한 많은 실행 경로를 도출하고, 각각의 효율성을 판단하는 것은 매우 고연산이 필요한 작업.
- 이렇게 어려운 작업을 거쳐서 생성된 프로시저를 일회성으로 사용한다면 매우 비효율적.

## 바인드 변수의 중요성
**이름 없는 SQL 문제**
SQL이 프로시저나 트리거, 패키지처럼 저장되지 않는 이유는 뭘까? (물론 저장하는 DBMS도 있긴 함.)
- SQL은 그 자체가 이름이고 식별자
- 따라서 매 수정마다 새로운 객체가 생성되는 꼴.
- 특히 개발 단계에서는 일회성 SQL을 많이 사용하게 되는데, 이때마다 SQL을 저장한다면 매우 비효율적.

**공유 가능 SQL**
SQL은 그 자체가 이름. -> 같은 로직을 수행하는 SQL들이더라도, 텍스트가 다르면 매번 새로 최적화되고, 라이브러리 캐시에 캐싱.

```sql
SELECT * FROM CUSTOMER WHERE LOGIN_ID = '" + login_id + "';
```
- 만약 위와 같은 SQL이 있고, 특정 이벤트나 프로모션으로 인해, 한 순간 로그인 유저가 몰리는 경우, CPU는 로그인 유저 당 1개의 내부 프로시저를 만드느라 펑!

그럼 로그인 유저 당 1개의 프로시저가 아니라, 로그인 유저를 파라미터로 받는 프로시저가 1개 생성된다면 모두 처리 가능할 것
- 이를 위해 **바인드 변수**가 필요.

```sql
SELECT * FROM CUSTOMER WHERE LOGIN_ID = ?;
```

# 데이터 저장 구조 및 I/O 메커니즘
I/O 튜닝 == SQL 튜닝

## SQL이 느린 이유
Dist I/O 때문.
- 구체적으로는 실제 데이터가 저장된 스토리지로부터, 데이터베이스 서버로의 I/O 채널에서의 병목 때문.

I/O => **잠**
- OS 또는 다른 서브 시스템이 I/O를 처리하는 동안 프로세스는 아무것도 하지 않고 자기 때문.

> 프로세스 생명주기 : 프로세스는 생성, 준비, 실행, 대기, 종료와 같은 상태를 가질 수 있다. interrupt 에 의해 상태가 변경된다.

열일하던 프로세스는 디스크에서 데이터를 읽어야 할 때, 즉 I/O가 필요할 때, CPU에 제어권을 넘기고, 대기 상태로 돌입.
- 따라서 **많은 프로세스가 I/O 를 필요로 하면, 대기 프로세스가 많아져 성능이 나빠진다.**

스토리지의 성능이 좋아져서, I/O Call 속도나 대기 시간이 짧아지고는 있지만, 여전히 많은 양의 프로세스가 요구하는 I/O 는 성능을 좌지우지한다.

## 데이터베이스 저장 구조
먼저 **테이블스페이스.**
- 세그먼트 여러 개가 담기는 컨테이너 역할
- 여러 개의 데이터 파일로 구성

다음으로는 **세그먼트.**
- 테이블, 인덱스처럼 데이터 저장공간이 필요한 오브젝트
- 세그먼트 자체는 논리적이고 가상적인 개념이지만, 이를 구성하는 물리적인 공간(익스텐트, 블록)은 실제 디스크에 위치
- 여러 개의 익스텐트가 위치

다음은 **익스텐트.**
- 연속된 블록들의 집합
- 파티션 구조냐 아니냐로 구분되는데,
  - 파티션 구조가 아닌 경우 : 테이블, 인덱스 모두 각각 하나의 세그먼트
  - 파티션 구조 : 각 파티션이 하나의 세그먼트
- 익스텐트 단위로 세그먼트 내에서 공간을 확장.

마지막으로 **데이터 블록.** (혹은 페이지)
- 실제로 레코드가 저장되는 공간
- 한 블록은 하나의 테이블이 독점 => 한 블록에 저장된 레코드는 모두 같은 테이블 레코드
- 한 익스텐트도 하나의 테이블이 독점 => 한 익스텐트에 담긴 블록은 모두 같은 테이블 블록

**위 구성요소들과 데이터파일 간의 관계**
- 세그먼트에 할당된 모든 익스텐트가 같은 데이터파일에 위치하지 않을 수 있다. => DBMS가 파일 경합을 줄이기 위해 데이터를 가능한 한 여러 데이터파일로 분산 저장하기 때문.
- 1번 데이터 파일에, 서로 다른 세그먼트의 익스텐트들이 연속할 수 있다.

> DBA: Data Block Address (디스크 상에서 몇 번 데이터 파일의 몇 번째 블록인가를 나타내는 값)

테이블 스페이스에 대한 참고 : https://westlife0615.tistory.com/154

## 블록 단위 I/O
DB에서 데이터를 읽고 쓰는 단위 ? **블록**
- 하나의 레코드를 읽고 싶을때도, 블록 단위로 읽어야 함.
- 인덱스 또한 블록 단위로 사용

mysql의 기본 block size 는 16KB
- innodb_page_size 값 참고.

> **page ? block ?**
> : block은 일반적으로 디스크 I/O에서 사용되는 용어이고, page는 InnoDB 스토리지 엔진에서 데이터 저장 단위로 사용되는 용어.
> - 하지만 mysql에서는 두 값이 같아서 같은 의미로 쓰이긴 함.

## 시퀀셜 액세스 vs. 랜덤 액세스
액세스 ? 블록을 읽는 것.

**Sequential Access**
- 논리, 물리적 연결 순서대로 블록을 읽는 것.
- 인덱스의 경우, 리프 블록이 가지는 앞 뒤 주소값을 참조해서 순서대로 읽기
- 테이블의 경우, 각 세그먼트가 익스텐트 목록을 맵으로 가짐. value 는 각 익스텐트의 첫 블록 주소. 이거부터 순차적으로 읽기

**Random Access**
- 레코드 하나를 읽기 위해 한 블록씩 순서 없이 읽는 것.
