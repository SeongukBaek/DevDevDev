## Contents
- [SQL 파싱과 최적화](#sql-파싱과-최적화)
  - [구조적, 집합적, 선언적 질의 언어](#구조적-집합적-선언적-질의-언어)
  - [SQL 최적화](#sql-최적화)
  - [SQL 옵티마이저](#sql-옵티마이저)
  - [실행계획과 비용](#실행계획과-비용)
  - [옵티마이저 힌트](#옵티마이저-힌트)
- [SQL 공유 및 재사용](#sql-공유-및-재사용)
  - [소프트 파싱 vs. 하드 파싱](#소프트-파싱-vs-하드-파싱)
  - [바인드 변수의 중요성](#바인드-변수의-중요성)
- [데이터 저장 구조 및 I/O 메커니즘](#데이터-저장-구조-및-io-메커니즘)
  - [SQL이 느린 이유](#sql이-느린-이유)
  - [데이터베이스 저장 구조](#데이터베이스-저장-구조)
  - [블록 단위 I/O](#블록-단위-io)
  - [시퀀셜 액세스 vs. 랜덤 액세스](#시퀀셜-액세스-vs-랜덤-액세스)
  - [논리적 I/O vs. 물리적 I/O](#논리적-io-vs-물리적-io)
  - [Single Block I/O vs. MultiBlock I/O](#single-block-io-vs-multiblock-io)
  - [Table Full Scan vs. Index Range Scan](#table-full-scan-vs-index-range-scan)
  - [캐시 탐색 매커니즘](#캐시-탐색-매커니즘)

# SQL 파싱과 최적화
## 구조적, 집합적, 선언적 질의 언어
SQL => '구조적', '집합적', '선언적'
- 하지만, 결과 생성 과정은 **절차적**일 수 밖에 없다.
- 이를 위해서는 '프로시저' 필요 (프로시저 : 특정 작업을 수행하기 위해 일련의 명령어들을 모아놓은 것)
- 그리고 이 프로시저를 만드는 DBMS 내부 엔진이 **SQL 옵티마이저**

## SQL 최적화
> SQL 최적화 : 프로시저를 만들고, 컴파일해서, 실행 가능한 상태로 만드는 것 (ex. 자바 빌드)

1. 파싱
    - 트리 생성: 개벌 구성요소 분석 후 트리 생성
    - Syntax 체크: 사용할 수 없는 키워드? 순서 오류? 키워드 누락?
    - Semantic 체크: 존재하는 테이블? 권한 보유?
2. 최적화
    - 수집한 정보 바탕으로 다양한 실행경로 생성 후, 비교해서 효율적인 하나 채택
3. 로우 소스 생성
    - 프로시저 형태로 포맷팅
  
## SQL 옵티마이저
- 파싱 트리 생성
- 실행계획 예상 비용 산정 <- 오브젝트 통계 및 시스템 통계정보가 비용 책정에 사용
- 최저 비용 선택

## 실행계획과 비용
실행계획을 어떻게 확인할까 (mysql 기준)
- explain: 통계정보를 기반으로 유추
- explain analyze (8.0.18 버전 이상): 실제 쿼리를 실행한 결과

<img width="614" alt="스크린샷 2024-08-13 20 10 04" src="https://github.com/user-attachments/assets/d04c73af-84ee-42f3-8015-033ea66082a8">
<img width="491" alt="스크린샷 2024-08-13 20 10 33" src="https://github.com/user-attachments/assets/4e2eceb2-16e3-41d5-89f4-05253f686c22">

## 옵티마이저 힌트
옵티마이저가 판단한 최적화 방식이 아니라, 개발자의 판단을 따라 수행할 수 있도록 지정해주는 것.

```sql
SELECT /*+ INDEX(post user_id_idx)
  user_id, name
from post
where user_id = '1234';
```

# SQL 공유 및 재사용
## 소프트 파싱 vs. 하드 파싱
**라이브러리 캐시**: 최적화 과정을 통해 생성된 프로시저를 캐싱하는 메모리 공간
- System Global Area 의 구성 요소

**소프트 파싱** : 사용자가 전달한 SQL이 라이브러리 캐시에 존재해서, 바로 실행되는 것
**하드 파싱** : 사용자가 전달한 SQL이 라이브러리 캐시에 존재하지 않아서, 최적화과정을 통해 프로시저를 새로 생성하는 것

그럼 왜 라이브러리 캐시를 통해 SQL 프로시저를 캐싱할까?
- ex. 자동차 내비게이션
- 주어진 SQL를 수행하는데 후보군이 될 만한 많은 실행 경로를 도출하고, 각각의 효율성을 판단하는 것은 매우 고연산이 필요한 작업.
- 이렇게 어려운 작업을 거쳐서 생성된 프로시저를 일회성으로 사용한다면 매우 비효율적.

## 바인드 변수의 중요성
**이름 없는 SQL 문제**
SQL이 프로시저나 트리거, 패키지처럼 저장되지 않는 이유는 뭘까? (물론 저장하는 DBMS도 있긴 함.)
- SQL은 그 자체가 이름이고 식별자
- 따라서 매 수정마다 새로운 객체가 생성되는 꼴.
- 특히 개발 단계에서는 일회성 SQL을 많이 사용하게 되는데, 이때마다 SQL을 저장한다면 매우 비효율적.

**공유 가능 SQL**
SQL은 그 자체가 이름. -> 같은 로직을 수행하는 SQL들이더라도, 텍스트가 다르면 매번 새로 최적화되고, 라이브러리 캐시에 캐싱.

```sql
SELECT * FROM CUSTOMER WHERE LOGIN_ID = '" + login_id + "';
```
- 만약 위와 같은 SQL이 있고, 특정 이벤트나 프로모션으로 인해, 한 순간 로그인 유저가 몰리는 경우, CPU는 로그인 유저 당 1개의 내부 프로시저를 만드느라 펑!

그럼 로그인 유저 당 1개의 프로시저가 아니라, 로그인 유저를 파라미터로 받는 프로시저가 1개 생성된다면 모두 처리 가능할 것
- 이를 위해 **바인드 변수**가 필요.

```sql
SELECT * FROM CUSTOMER WHERE LOGIN_ID = ?;
```

# 데이터 저장 구조 및 I/O 메커니즘
I/O 튜닝 == SQL 튜닝

## SQL이 느린 이유
Dist I/O 때문.
- 구체적으로는 실제 데이터가 저장된 스토리지로부터, 데이터베이스 서버로의 I/O 채널에서의 병목 때문.

I/O => **잠**
- OS 또는 다른 서브 시스템이 I/O를 처리하는 동안 프로세스는 아무것도 하지 않고 자기 때문.

> 프로세스 생명주기 : 프로세스는 생성, 준비, 실행, 대기, 종료와 같은 상태를 가질 수 있다. interrupt 에 의해 상태가 변경된다.

열일하던 프로세스는 디스크에서 데이터를 읽어야 할 때, 즉 I/O가 필요할 때, CPU에 제어권을 넘기고, 대기 상태로 돌입.
- 따라서 **많은 프로세스가 I/O 를 필요로 하면, 대기 프로세스가 많아져 성능이 나빠진다.**

스토리지의 성능이 좋아져서, I/O Call 속도나 대기 시간이 짧아지고는 있지만, 여전히 많은 양의 프로세스가 요구하는 I/O 는 성능을 좌지우지한다.

## 데이터베이스 저장 구조
먼저 **테이블스페이스.**
- 세그먼트 여러 개가 담기는 컨테이너 역할
- 여러 개의 데이터 파일로 구성

다음으로는 **세그먼트.**
- 테이블, 인덱스처럼 데이터 저장공간이 필요한 오브젝트
- 세그먼트 자체는 논리적이고 가상적인 개념이지만, 이를 구성하는 물리적인 공간(익스텐트, 블록)은 실제 디스크에 위치
- 여러 개의 익스텐트가 위치

다음은 **익스텐트.**
- 연속된 블록들의 집합
- 파티션 구조냐 아니냐로 구분되는데,
  - 파티션 구조가 아닌 경우 : 테이블, 인덱스 모두 각각 하나의 세그먼트
  - 파티션 구조 : 각 파티션이 하나의 세그먼트
- 익스텐트 단위로 세그먼트 내에서 공간을 확장.

마지막으로 **데이터 블록.** (혹은 페이지)
- 실제로 레코드가 저장되는 공간
- 한 블록은 하나의 테이블이 독점 => 한 블록에 저장된 레코드는 모두 같은 테이블 레코드
- 한 익스텐트도 하나의 테이블이 독점 => 한 익스텐트에 담긴 블록은 모두 같은 테이블 블록

**위 구성요소들과 데이터파일 간의 관계**
- 세그먼트에 할당된 모든 익스텐트가 같은 데이터파일에 위치하지 않을 수 있다. => DBMS가 파일 경합을 줄이기 위해 데이터를 가능한 한 여러 데이터파일로 분산 저장하기 때문.
- 1번 데이터 파일에, 서로 다른 세그먼트의 익스텐트들이 연속할 수 있다.

> DBA: Data Block Address (디스크 상에서 몇 번 데이터 파일의 몇 번째 블록인가를 나타내는 값)

테이블 스페이스에 대한 참고 : https://westlife0615.tistory.com/154

## 블록 단위 I/O
DB에서 데이터를 읽고 쓰는 단위 ? **블록**
- 하나의 레코드를 읽고 싶을때도, 블록 단위로 읽어야 함.
- 인덱스 또한 블록 단위로 사용

mysql의 기본 block size 는 16KB
- innodb_page_size 값 참고.

> **page ? block ?**
> : block은 일반적으로 디스크 I/O에서 사용되는 용어이고, page는 InnoDB 스토리지 엔진에서 데이터 저장 단위로 사용되는 용어.
> - 하지만 mysql에서는 두 값이 같아서 같은 의미로 쓰이긴 함.

## 시퀀셜 액세스 vs. 랜덤 액세스
액세스 ? 블록을 읽는 것.

**Sequential Access**
- 논리, 물리적 연결 순서대로 블록을 읽는 것.
- 인덱스의 경우, 리프 블록이 가지는 앞 뒤 주소값을 참조해서 순서대로 읽기
- 테이블의 경우, 각 세그먼트가 익스텐트 목록을 맵으로 가짐. value 는 각 익스텐트의 첫 블록 주소. 이거부터 순차적으로 읽기

**Random Access**
- 레코드 하나를 읽기 위해 한 블록씩 순서 없이 읽는 것.

## 논리적 I/O vs. 물리적 I/O
DBMS에 캐싱이 필수인 이유? 
- 디스크 I/O가 SQL의 성능을 결정. => 자주 읽는 데이터 블록을 매번 디스크에 접근해서 가져오는 것은 매우 비효율적!

> 라이브러리 캐시 : 프로시저를 캐싱 -> 코드 캐싱
> DB 버퍼 캐시 : 데이터 캐싱
> - 공유 메모리에서 존재하기에, 다른 프로세스에서도 사용 가능

**논리적 Block I/O**: SQL을 처리하는 과정에서 발생한 총 Block I/O (== 메모리 I/O)
- 이는 전기적 신호 작용

**물리적 Block I/O**: 디스크에서 발생한 총 Block I/O
- 버퍼 캐시에서 데이터를 찾지 못하는 경우만 발생 (따라서, 논리적 Block I/O에 포함되는 I/O)
- 액세스 암을 통한 물리적 작용
- 버퍼 캐시에 없는 경우만 발생하므로, 물리적 Block I/O는 실행마다 달라진다. (캐싱이 될 것이기 때문)

> 1물리적 I/P == 10,000논리적 I/O (성능)

**버퍼 캐시 히트율(버퍼 캐시 효율 측정, Buffer Cache Hit Ratio)** : 물리적 Block I/O 없이, 바로 메모리(버퍼 캐시)에서 데이터를 찾는 비율
- (캐시에서 바로 찾은 블록 수 / 총 읽은 블록 수) * 100%
- ((논리적 Block I/O - 물리적 Block I/O) / 논리적 Block I/O) * 100%

> 온라인 트랜잭션을 처리하는 애플리케이션의 경우, 평균 99%의 BCHR이 나와야 함.

공식을 통해 도출할 수 있는 결과.
- 물리적 Block I/O가 성능에 영향을 주는 것은 맞지만, 실질적인 성능 향상을 위해서라면 논리적 Block I/O를 줄이는 것이 중요하다.
  - 위 식을 조금만 수정하면, `물리적 Block I/O = 논리적 Block I/O * (100% - BCHR)` 을 얻을 수 있고, 곧 물리적 Block I/O는 논리적 Block I/O에 비례함을 알 수 있다.
  - 또한, 물리적 Block I/O는 시스템 상황적인 변수이므로, 우리가 통제하기 어렵다.
  - 따라서, 우리가 통제할 수 있는 변수인 논리적 Block I/O를 줄이는 것이 곧 성능 향상.
 
논리적 Block I/O를 어떻게 줄일 것인가?
- SQL 튜닝을 통해, 읽어야 하는 블록 수를 줄이자.

> BCHR이 높으면, 효율적인 SQL일까?
> - 아니다. 같은 블록을 비효율적으로 반복해서 읽으면 BCHR이 높아진다. 이런 경우가 있을 수 있기 때문에 무조건 효율적이라고는 할 수 없다.

## Single Block I/O vs. MultiBlock I/O
**Single Block I/O**: I/O Call을 통해 디스크에서 버퍼 캐시로 블록을 적재할 때, 1번에 1개의 블록을 요청하는 것.
- 인덱스와 테이블 블록 모두 Single Block I/O를 이용
  - 인덱스의 경우, 주로 소량의 데이터를 읽는데 사용하기 때문에, 적합

**MultiBlock I/O**: 1번에 여러 개의 Block을 요청하는 것.
- 이때, 한 블록와 그 인접한 블록들을 한꺼번에 요청. 그리고 인접한 블록이라 함은, 같은 익스텐트에 속한 블록을 말한다.
  - 만약, MultiBlock I/O의 단위가 4라면, 4개 블록씩 요청할텐데, 만약 현재 익스텐트에 남은 블록이 4개보다 적다고 해도, 다음 익스텐트의 블록을 요청하지는 않는다.
- 주로 많은 데이터 블록을 읽을 때 적합 (ex. 테이블 풀 스캔)
- 테이블이 클수록, MultiBlock I/O 단위를 크게 해야, I/O 횟수가 줄어들 것.

> DBMS에서 MultiBlock I/O 단위를 얼마로 하던지에 관계없이, OS는 보통 1MB단위로 I/O를 요청한다. (OS마다 다름.)
> - 따라서 DBMS에서 설정하는 단위는 최대 1MB까지가 의미있다.

**MultiBlock I/O 중, Single Block I/O가 발생한다?**
- 데이터 블록을 적재할때 순서대로 적재할텐데, 캐싱된 블록 사이의 블록이 1개라면, 해당 블록에 대해서는 Single Block I/O가 발생해야 할 것이다.
- `캐싱된 블록 1, 블록 2, 캐싱된 블록 3, 블록 4, 블록 5, 캐싱된 블록 6` 과 같이 있다면, 블록 2에 대해서는 Single Block I/O이, 블록 4, 5에 대해서는 Multi Block I/O이 발생할 것이다.

## Table Full Scan vs. Index Range Scan
테이블을 읽는 방식은 2가지.
- Table Full Scan : 테이블에 속한 블록 전체를 읽는 것.
- Index Range Scan : 인덱스에서 일정량만 Scan해서 얻은 ROWID(레코드의 주소)로 레코드를 읽는 것.

> Table Full Scan이 항상 성능 저하의 요인은 아닐 수 있다. 오히려 Index Range Scan이 성능 저하의 요인이 될 수 있다.

**인덱스를 사용하는데 더 느려진다?**
- Table Full Scan의 경우 : 시퀀셜 액세스 + MultiBlock I/O
  - 즉, 물리적 I/O 횟수가 상대적으로 적을 것.
  - 따라서, 스토리지 스캔 성능(디스크에서 데이터를 읽어오는 과정의 효율성과 속도)이 좋을수록, 성능 또한 향상된다.
  - 하지만 큰 테이블에서 소량의 데이터를 읽어야 하는 경우는 인덱스르 사용하는 것이 효율적.
- Index Range Scan의 경우 : 랜덤 액세스 + Single Block I/O
  - 즉, 물리적 I/O 횟수가 상대적으로 많을 것.
  - 스토리지 스캔 성능이 아무리 좋아진다한들, 성능이 그에 비례해서 좋아지진 않는다.
  - 많은 데이터를 읽어야 하는 경우는 불리.
  - 또한 읽었던 블록을 비효율적으로 반복해서 읽을 수 있다.

> 인덱스가 항상 모든 성능 문제의 해결책이 될 수는 없다는 것을 알려준다.

## 캐시 탐색 매커니즘
모든 블록 I/O는 메모리 버퍼 캐시를 경유한다. (Direct Path I/O 제외)
- 따라서, 버퍼 캐시를 탐색하는 알고리즘이 중요할 것.

> Direct Path I/O : 디스크에서 직접 메모리로 전송되거나 메모리에서 디스크로 직접 쓰이는 I/O 방식

먼저, **버퍼 캐시의 구조** : 해시 구조 (ex. 모듈러 함수 사용)
- 특정 블록에 대해 특정 해시 체인만 탐색할 수 있도록.
- 없으면 물리적 I/O 수행해서 캐싱
- 해시 체인 내에서는 정렬 X

하지만, 메모리 버퍼 캐시는 공유 메모리에 위치한다. => **동시성 문제가 발생**할 수 있다.
- 따라서, 자원 공유처럼 보이지만, 내부적으로는 프로세스 1개씩 순차적으로 접근하도록 하는 '직렬화 매커니즘' 필요. (일종의 Lock 필요)

> 이러한 줄 세우기 전략이 적용되면, 캐시 경합이 발생할 것이고, 이를 줄이기 위해서는 결국 SQL 튜닝을 통한 논리적 I/O의 감소가 필요하다.
