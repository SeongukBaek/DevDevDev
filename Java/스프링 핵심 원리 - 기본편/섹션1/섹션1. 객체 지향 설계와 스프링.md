TOC
- [스프링의 탄생 배경](#스프링의-탄생-배경)
  - [EJB?](#ejb)
  - [EJB 지옥](#ejb-지옥)
- [스프링 역사](#스프링-역사)
  - [전설의 시작](#전설의-시작)
  - [릴리즈](#릴리즈)
- [스프링이란?](#스프링이란)
  - [스프링 생태계](#스프링-생태계)
  - [스프링 프레임워크](#스프링-프레임워크)
  - [스프링 부트](#스프링-부트)
  - [스프링은 왜 만들었나?](#스프링은-왜-만들었나)
- [좋은 객체 지향 프로그래밍?](#좋은-객체-지향-프로그래밍)
  - [객체 지향 특징](#객체-지향-특징)
  - [다형성(Polymorphism)](#다형성polymorphism)
  - [역할과 구현을 분리](#역할과-구현을-분리)
  - [다형성의 본질](#다형성의-본질)
  - [스프링과 객체 지향](#스프링과-객체-지향)
- [좋은 객체 지향 설계의 5가지 원칙(SOLID)](#좋은-객체-지향-설계의-5가지-원칙solid)
  - [SRP : 단일 책임 원칙(Single Responsibility Principle)](#srp--단일-책임-원칙single-responsibility-principle)
  - [OCP : 개방 - 폐쇄 원칙(Open/Closed Principle)](#ocp--개방---폐쇄-원칙openclosed-principle)
  - [LSP : 리스코프 치환 원칙(Liskov Substitution Principle)](#lsp--리스코프-치환-원칙liskov-substitution-principle)
  - [ISP : 인터페이스 분리 원칙(Interface Segregation Principle)](#isp--인터페이스-분리-원칙interface-segregation-principle)
  - [DIP : 의존관계 역전 원칙(Dependency Inversion Principle)](#dip--의존관계-역전-원칙dependency-inversion-principle)
- [객체 지향 설계와 스프링](#객체-지향-설계와-스프링)
- [정리](#정리)
  - [실무 고민](#실무-고민)

# 스프링의 탄생 배경
## EJB?
2000년대 초반, 자바 진영의 표준 기술인 **EJB(Enterprise Java Beans)** 가 존재했다.
- 금융권에서 주로 사용하는 기술이었다.
- 분산 처리에 대한 지원이 잘 되었다.
- 또한 Entity Bean이라는 ORM 기술 또한 갖추고 있었다.

하지만, **비싸다**는 단점이 존재했다. (수천만원에 이르는 서버 비용...)

## EJB 지옥
이러한 EJB는, 이론적으로는 엄청난 기술이었으나, 실전에서는 **어렵고, 복잡고, 느리다**는 문제점이 존재했다.
- **EJB가 제공하는 인터페이스를 모두 구현**해야 하고,
- **EJB에 의존적인 구현**을 해야 했다.

따라서, `POJO(Plain Old Java Object)` 라는 용어가 등장하게 되었다.
- 오래된 방식의 간단하고 순수한 자바를 사용하자!

이러한 지옥을 탈출하기 위해 두 명의 개발자가 등장한다.
- Hibernate를 만든 **Gavin King**
  - EJB의 Entity Bean 기술을 대체
- 지금의 스프링 프레임워크의 시초를 만든 **Rod Johnson**
  - EJB 컨테이너를 대체
  
Hibernate가 등장하면서, 기존의 Entity Bean 기술의 활용도가 점점 낮아지게 되었다.
-> 따라서, Hibernate를 만든 Gavin King과 함께 **JPA**라는 **새로운 자바 표준을 정의**하게 되었다.

JPA는 **자바의 표준 인터페이스**이므로, 이를 사용하기 위한 구현체가 필요하다.
- Hibernate, EclipseLink, ...이 JPA의 구현체이다.

> JPA와 Hibernate는 자바 진영에 매우 잘 정착하게 된다.

---

# 스프링 역사
## 전설의 시작
2002년 Rod Johnson이 EJB의 문제점을 지적하는 책을 출판하게 되면서 스프링의 시초가 되었다.
- 해당 책의 예제 코드에는 스프링 핵심 개념과 기반 코드를 포함하고 있었다.
- BeanFactory, ApplicationContext, POJO, 제어의 역전, 의존관계 주입 등

여기에 Juergen Hoeller, Yann Caroff가 합류하여 오픈소스 프로젝트를 진행하게 되면서, 스프링이 만들어지게 되었다.

> 전통적인 J2EE라는 겨울을 넘어 새로운 시작이라는 의미로 Spring라는 이름이 붙게 되었다.

## 릴리즈
- 2003년 스프링 프레임워크 1.0 출시 - XML
- 2006년 스프링 프레임워크 2.0 출시 - XML 편의 기능 지원
- 2009년 스프링 프레임워크 3.0 출시 - 자바 코드로 설정
- 2013년 스프링 프레임워크 4.0 출시 - 자바8
- 2014년 스프링 부트 1.0 출시
- 2017년 스프링 프레임워크 5.0, 스프링 부트 2.0 출시 - 리엑티브 프로그래밍 지원 2020년 9월 현재 스프링 프레임워크 5.2.x, 스프링 부트 2.3.x
- 2022년 스프링 프레임워크 6.0 출시
- 2023년 스프링 부트 3.1 출시

---

# 스프링이란?
## 스프링 생태계
스프링은 단순히 한 기술을 말하는 것이 아닌, 여러 기술의 복합체라고 할 수 있다.
- 필수 : 스프링 프레임워크, 스프링 부트
- 선택 : 스프링 데이터, 세션, 시큐리티, Rest Docs, 배치, 클라우드 등

## 스프링 프레임워크
스프링 프레임워크는 또한 아래와 같은 기술들로 구성된다.
- 핵심 기술: 스프링 DI 컨테이너, AOP, 이벤트, 기타
- 웹 기술: 스프링 MVC, 스프링 WebFlux
- 데이터 접근 기술: 트랜잭션, JDBC, ORM, XML 지원
- 기술 통합: 캐시, 이메일, 원격접근, 스케줄링
- 테스트: 스프링 기반 테스트 지원
- 언어: 코틀린, 그루비

## 스프링 부트
스프링을 굉장히 편리하게 사용할 수 있도록 돕는 기술이다.
- 단독으로 실행할 수 있는 스프링 애플리케이션을 쉽게 생성
  - 톰캣 같은 웹 서버를 내장하고 있어 별도의 웹 서버 설치가 필요없음
- 손쉬운 빌드 구성을 위해 starter 종속성 제공
- 스프링과 써드 파티 라이브러리 자동 구성
  - 사용하는 외부 라이브러리의 버전 관리를 자동으로 해줌!
- 메트릭, 상태 확인, 외부 구성 같은 프로덕션 준비 기능 제공
- 관례에 의한 간결한 설정

> 스프링 부트는 스프링과 별도로 동작하는 기술이 아니다!

## 스프링은 왜 만들었나?
**스프링의 핵심 개념**
-> **"자바 언어 기반의 프레임워크"**

**자바 언어의 가장 큰 특징** 
-> **"객체 지향 언어"**

- 스프링은 객체 지향 언어의 특징을 살려내는 프레임워크

=> **"좋은 객체 지향 애플리케이션을 개발할 수 있도록 도와주는 프레임워크"**

> "EJB는 객체 지향의 장점을 살리지 못하는 기술이었다!"
> - EJB에 종속적인 애플리케이션을 개발할 수 밖에 없는 구조였다.

---

# 좋은 객체 지향 프로그래밍?
## 객체 지향 특징
- 추상화
- 캡슐화
- 상속
- 다형성

객체 지향 프로그래밍은 컴퓨터 프로그램을 **객체들의 모임**으로 보고 각 객체는 **메세지**를 통해 소통한다. 이를 통해 프로그램을 **유연하고 변경이 용이**하게 만들 수 있다.

## 다형성(Polymorphism)
**다형성의 실세계 비유**
- 세상을 역할과 구현으로 구분!
- 운전자 - 자동차
- 공연 무대
- 키보드, 마우스, 세상의 표준 인터페이스들
- 정렬 알고리즘
- ...

**운전자 - 자동차**
![운전자-자동차](../image/스크린샷%202023-06-15%2016.03.00.png)

자동차의 역할을 서로 다른 3개의 모델이 구현을 하고 있다.
- 운전자는 K3를 타다가, 아반떼로 갈아타도 운전이라는 역할을 수행할 수 있다.

단지 구현이 변경된 것뿐이고, 운전자에게는 영향이 없다.
- 이는 자동차의 역할의 인터페이스를 따라 각 모델이 구현했기 때문이다.
- 운전자는 자동차의 역할에 대해서만 인지하고 있다.
- 그리고 이는 운전자(클라이언트)를 위함이다.
  - 운전자는 내부 구현의 변경은 영향이 없고, 알 필요가 없다.

따라서 이러한 다형성을 통해 **클라이언트에 영향을 주지 않고 새로운 기능(자동차)을 제공**할 수 있게 된다.

## 역할과 구현을 분리
역할과 구현으로 구분하면 **세상이 단순**해지고, **유연**해지며 **변경**도 편리해진다.

**장점** (모두 **클라이언트** 관점)
- 클라이언트는 대상의 역할(인터페이스)만 알면 된다.
- 클라이언트는 구현 대상의 **내부 구조를 몰라도** 된다.
- 클라이언트는 구현 대상의 **내부 구조가 변경**되어도 영향을 받지 않는다.
- 클라이언트는 구현 **대상 자체를 변경**해도 영향을 받지 않는다. (테슬라 -> K3)

**자바 언어에서의 차용**
- 역할 = 인터페이스
- 구현 = 인터페이스 구현체
- 객체 설계 시 **역할과 구현을 명확히 분리**
  - 역할(인터페이스)을 먼저 부여하고, 해당 역할을 수행하는 구현 객체 생성 (역할이 더 중요하다!)

> 물론 역할이 클래스가 될 수도 있지만, 자바에서는 다중 상속이 불가능하므로 확장성을 가질 수 없다!

**오버라이딩**
- 자바의 기본 문법으로, 부모 객체의 메소드를 자식 객체에서 재정의하여, 실제 메소드 호출 시 오버라이딩된 메소드가 호출되는 것을 말한다.
- 이는 자바에서의 다형성의 예로, 인터페이스를 구현한 객체를 실행 시점에 유연하게 변경할 수 있도록 한다.

## 다형성의 본질
인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경할 수 있다.

**"클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다."**

> 구현체가 아닌 인터페이스에 의존하게 됨으로써, 무한한 확장성을 가질 수 있게 된다.
> - 하지만 이로 인해, 인터페이스 자체가 변경된다면, 클라이언트와 서버 모두에 큰 변경이 발생하게 된다.
>
> => **즉, 인터페이스를 안정적으로 잘 설계하는 것이 중요하다!**

## 스프링과 객체 지향
**"객체 지향의 꽃은 다형성이다"**라고 할 수 있을 정도로 다형성은 매우 중요한 개념이다.
- 그리고 스프링은 다형성을 극대화해서 이용할 수 있게 도와준다.
  - 제어의 역전, 의존관계 주입은 다형성을 활용하고 있다.

---

# 좋은 객체 지향 설계의 5가지 원칙(SOLID)
## SRP : 단일 책임 원칙(Single Responsibility Principle)
하나의 클래스는 하나의 책임만 가져야 한다.
- 하나의 책임은 모호하다.
- 이때, 중요한 기준은 변경이다. 
  - 변경이 있을 때 파급력이 적다면, 해당 원칙을 잘 따를 것이라고 할 수 있다.

## OCP : 개방 - 폐쇄 원칙(Open/Closed Principle)
SW요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
- 역할과 구현을 분리함으로써, 해당 원칙을 지킬 수 있다. (하지만 추가적인 작업이 필요하다.)

**문제점**
- `MemberService` 에서 사용할 `Repository` 클래스를 직접 선택하는데, 이때 `Repository` 구현 객체를 변경하려면, 아래와 같이 코드를 변경해야 한다. -> **"변경에 닫혀 있지 않다!"**

```java
// MemberRepository m = new MemoryMemberRepository(); //기존 코드
MemberRepository m = new JdbcMemberRepository(); //변경 코드
```

이를 위해 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다!
-> **스프링 컨테이너가 수행한다.**

## LSP : 리스코프 치환 원칙(Liskov Substitution Principle)
프로그램 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
- 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것, 다형성을 지원하기 위한 원칙, 인터페이스를 구현한 구현체는 믿고 사용하려면, 이 원칙이 필요하다.
- 컴파일에 성공하는 것을 넘어서는 원칙 -> 런타임에서도 기능적인 보장을 해줘야 한다는 원칙!

## ISP : 인터페이스 분리 원칙(Interface Segregation Principle)
특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
- 자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스로 분리
- 사용자 인터페이스 -> 운전자 클라이언트, 정비사 클라이언트로 분리
- 분리하면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않는다!
- **인터페이스가 명확해지고, 대체 가능성이 높아진다.**

## DIP : 의존관계 역전 원칙(Dependency Inversion Principle)
"추상화에 의존해야지, 구체화에 의존하면 안된다." 의존성 주입은 이 원칙을 따르는 방법 중 하나다.
- 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 의미다.
- **역할(Role)에 의존하게 해야 한다**는 것과 같은 말이다. 구현체에 의존하게 되면, 변경이 아주 어려워진다.
  
```java
class MemberService {
  // private MemberRepository m = new MemoryMemberRepository(); //기존 코드
  private MemberRepository m = new JdbcMemberRepository(); //변경 코드
}
```
- `MemberService` 또한 DIP를 위반하고 있다.
- 인터페이스에 의존하고는 있지만, 구현 클래스에도 의존하고 있기 때문이다.
  - `MemberService` 에서 `Repository` 의 구현 클래스를 알고 있기 때문!

> **"다형성만으로는 OCP, DIP를 지킬 수 없다."**

---

# 객체 지향 설계와 스프링
스프링은 **DI와 DI 컨테이너**를 통해 **다형성 + OCP, DIP**를 가능하게 지원한다!
- DI(Dependency Injection) : 의존관계 주입
- DI 컨테이너 제공 : 자바 객체들을 컨테이너에서 관리하고 의존관계 연결 및 주입

=> 클라이언트 코드의 변경 없이 기능을 확장할 수 있도록 한다!

> 순수하게 자바로 OCP, DIP 원칙을 지키기 위해 개발을 하다보면, 결국 스프링 DI 컨테이너를 만들게 된다.

---

# 정리
- 모든 설계에 역할과 구현을 분리하자.
- 이상적으로는 모든 설계에 인터페이스를 부여하자.

## 실무 고민
- 인터페이스의 도입은 곧 추상화라는 비용의 발생으로 이어진다.
  - 비용 : 확인해야 하는 코드 Depth 증가
  - 따라서, 기능 확장 가능성을 고려해, 구체 클래스 사용와 인터페이스 도입 시점을 결정하자.