**TOC**

# 자바의 강점
안전하다.
- 메모리 충돌 오류로부터.
- 불변식이 지켜져서.

하지만 이러한 언어라고 해도, 다른 클래스로부터의 침범이 발생할 수 있다.

> 클라이언트가 불변식을 깨뜨릴 수 있기에, 방어적 프로그래밍이 필요하다.

# 방어적 프로그래밍이 필요한 경우
어떤 객체든 그 객체의 허락 없이 외부에서 내부를 수정하는 일은 불가능하다. 하지만 주의하지 않으면 이를 가능하도록 하는 경우가 발생.
- ex. `Date` 클래스
  - `setYear()` 와 같은 메소드로 쉽게 내부를 수정할 수 있음.
  - `Date` 클래스를 불변으로 사용하려는 경우, 위와 같은 메소드를 통해 쉽게 불변식이 깨질 수 있다.
  - 이 클래스 대신 `Instant` 클래스를 사용하자.
  - `Date` => 낡은 API
 
> 이번 아이템은 예전에 작성된 낡은 코드들을 대처하기 위한 아이템. `Date` 와 같은 낡은 API는 위험으로부터 안전하지 않다.

## 방어적 프로그래밍을 하는 방법
### 생성자에서의 방어적 복사
생성자에서 받은 가변 매개변수 각각을 **방어적으로 복사**해야 한다.
- 이후 해당 클래스의 인스턴스 안에서는 원본이 아닌 복사본을 사용!

```java
public Period(Date start, Date end) {
    this.start = new Date(start.getTime());
    this.end = new Date(end.getTime());

    if (this.start.compareTo(this.end) > 0) {
        // 예외 발생
    }
}
```
- 이전 아이템에서 다룬 **매개변수 유효성 검사를 방어적 복사 이후에 수행**했다.
  - 멀티스레드 환경이라면, 원본 객체의 유효성 검사 후 복사본을 만드는 순간, 다른 스레드가 원본 객체를 수정할 위험 존재.
- 또한 `clone()` 을 사용하지 않았다.
  - `Date` 는 final 클래스가 아니므로, `Date` 가 정의하지 않은 `clone()` 일 수 있으므로 사용하지 않아야 한다.
    - 하위 클래스의 인스턴스를 반환할 수도 있다.
  - **매개변수가 제 3자에 의해 확장될 수 있는 타입이라면, 방어적 복사본을 만들 떄 `clone()` 을 사용하지 않도록 하자.**

### 접근자가 복사본 반환
하지만 아직 여전히 `Period` 인스턴스를 변경 가능하다.
- 접근자가 내부의 가변 정보를 그대로 반환하기 때문.

```java
public Date start() {
    return new Date(start.getTime());
}
```

**이렇게 하면, 완벽하게 불변식을 지킬 수 있게 된다.**
- 리플렉션이나 네이티브 메소드를 사용하지 않는다면.

# 매개변수 방어적 복사의 또 다른 목적
불변 객체 생성 뿐만 아니라, **객체의 참조를 내부의 자료구조에 보관할 때, 이 객체의 변경이 해당 자료구조를 오동작시키는 경우로부터 방지하기 위함**이다.
- ex. 전달된 객체가 Map의 키, Set 인스턴스 저장되는 경우
  - 해당 객체가 변경되면 불변식이 깨질 것.

이와 같은 이유로, 또한 내부 객체를 클라이언트에 건네주기 전에도 방어적 복사를 수행해야 한다.
- 원본을 노출시켰다간, 클라이언트에서 수정해버릴 수도 있다.

> **"되도록 불변 객체들을 조합해 객체를 구성해야 방어적 복사를 할 일이 줄어든다."** - 아이템 17

# 방어적 복사의 문제점
방어적 복사는 코드만 봐도 알 수 있듯, **성능 저하**가 따르고, **항상 쓸 수 있는 것도 아니다.**
- 호출자가 내부를 수정하지 않을 것이라 확신한다면 생략할 수 있다.
- 이런 경우라도 문서화를 통해 내부를 수정하지 않아야 함을 명시해야 한다.
