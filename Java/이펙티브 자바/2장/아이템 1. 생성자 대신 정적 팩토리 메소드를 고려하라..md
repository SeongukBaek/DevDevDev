**TOC**
- [장점 1. 이름을 가질 수 있다.](#장점-1-이름을-가질-수-있다)
- [장점 2. 호출될 때마다 인스턴스를 새로 생성하지는 않아도 된다.](#장점-2-호출될-때마다-인스턴스를-새로-생성하지는-않아도-된다)
- [장점 3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.](#장점-3-반환-타입의-하위-타입-객체를-반환할-수-있는-능력이-있다)
- [장점 4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.](#장점-4-입력-매개변수에-따라-매번-다른-클래스의-객체를-반환할-수-있다)
- [장점 5. 정적 팩토리 메소드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.](#장점-5-정적-팩토리-메소드를-작성하는-시점에는-반환할-객체의-클래스가-존재하지-않아도-된다)
- [단점 1. 정적 팩토리 메소드만 제공하는 클래스는 하위 클래스를 만들 수 없다.](#단점-1-정적-팩토리-메소드만-제공하는-클래스는-하위-클래스를-만들-수-없다)
- [단점 2. 정적 팩토리 메소드는 프로그래머가 찾기 어렵다.](#단점-2-정적-팩토리-메소드는-프로그래머가-찾기-어렵다)
- [참고](#참고)

---

생성자는 클래스의 인스턴스를 얻는 전통적인 수단이다.
- 이와 별도로, 클래스의 인스터스를 반환하는 정적 메소드(static method)를 통해 클래스의 인스턴스를 얻을 수도 있다.
  - 이때 이를 **정적 팩토리 메소드**라고 한다.
- 아래는 `Boolean`에서 제공하는 정적 팩토리 메소드이다.

```java
public static Boolean valueOf(boolean b) {
    return b ? Boolean.TRUE : Boolean.FALSE;
} 
```

그럼 이 방식은 어떠한 장단점이 있을까?

# 장점 1. 이름을 가질 수 있다.
생성자의 경우, 하나의 시그니처로는 하나의 생성자만 만들 수 있고, 넘겨지는 매개변수와 생성자 자체만으로 반환될 객체의 특성을 설명해야 한다.
- 하지만 정적 팩토리 메소드의 경우, 메소드의 이름을 필요로 하기에, 이름을 통해 반환될 객체의 특성을 쉽게 묘사할 수 있다.
  - ex. `toEntity()`, `fromDto()`
- 의미적으로 생성자보다 장점이 있다.

> 정적 팩토리 메소드를 통해, 반환해야 할 인스턴스의 차이가 드러나는 인스턴스 제공 수단을 만들자.

> NTS-Shop을 하면서 적용해볼 수 있었던 부분.

# 장점 2. 호출될 때마다 인스턴스를 새로 생성하지는 않아도 된다.
미리 만들어둔 인스턴스를 반환하는 형태, 혹은 새로 생성한 인스턴스를 캐싱하여 재활용하는 형태가 될 것이다.
- 같은 객체가 자주 요청되는 상황이라면 성능을 상당히 끌어올릴 수 있다. 
  - 플라이웨이트 패턴과 유사하다.

> **플라이웨이트 패턴?**
> : 구조 디자인 패턴의 일종으로, 데이터를 공유해 메모리를 절약하는 패턴
> - 공통으로 사용되는 객체는 한 번만 생성되고, Pool에 의해 관리 및 사용되는 디자인 패턴

**인스턴스 통제 클래스**
- 언제 어느 인스턴스를 살아 있게 할 지를 통제하는 클래스
- 정적 팩토리 방식의 클래스는, 반복되는 요청에 같은 객체를 반환하는 방식으로 인스턴스들을 통제한다.
- 그리고 이러한 통제를 통해, 싱글톤 클래스, 인스턴스화 불가 클래스를 만들 수 있고, 불변 값 클래스에서 동치인 인스턴스가 단 하나뿐임을 보장할 수 있게 된다.

# 장점 3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.
자바의 다형성을 이용해서, 반환할 객체의 클래스를 자유롭게 선택할 수 있다.
- 생성자의 경우는, 항상 해당 클래스를 반환해야 한다.

자바 8에서부터 인터페이스에 정적 메소드를 사용할 수 있기 전에는, 인스턴스화 불가인 동반 클래스를 통해 반환할 객체의 클래스를 자유롭게 선택할 수 있는 메소드를 구현해야 했다.
- 하지만 자바 8 이후는 이러한 동반 클래스를 둘 필요성이 줄어들었다. 동반 클래스에 있는 `public static 멤버들` 대부분을 인터페이스로 옮기면 되기 때문이다.
  - 하지만 인터페이스에는 `public static 멤버` (자바 9 이후는 `private static 멤버` 까지)만 허용하기에 정적 메소드를 구현하는데 필요한 코드 중 많은 부분은 `package-private` 클래스에 둬야 할 수도 있다.

# 장점 4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
```java
public static <E extends Enum<E>> EnumSet<E> noneOf(Class<E> elementType) {
    Enum<?>[] universe = getUniverse(elementType);
    if (universe == null)
        throw new ClassCastException(elementType + " not an enum");

    if (universe.length <= 64)
        return new RegularEnumSet<>(elementType, universe);
    else
        return new JumboEnumSet<>(elementType, universe);
}
```
- 위 코드를 입력 매개변수의 크기에 따라 `RegularEnumSet` 또는 `JumboEnumSet` 를 반환하고 있다.
- 그리고 해당 클래스들은 모두 `EnumSet` 의 하위 타입이다.
- 클라이언트들은 두 클래스에 대해 모른다.
  - `EnumSet<...> enumSet = EnumSet.noneOf(...)` 와 같은 방식으로 사용하니, 어디서도 해당 클래스를 명시할 필요가 없기 때문이다.

# 장점 5. 정적 팩토리 메소드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.
다른 말로, 반환할 객체의 클래스가 컴파일 시점에는 존재하지 않더라도, 런타임에만 정적 팩토리 메소드 내에서 찾을 수 있으면 된다라는 의미지 않을까.

> JDBC와 같은 서비스 제공자 프레임워크를 만드는 근간이 되는 특징이다.
> - DB와의 연결을 열고 닫는 것과 모든 하위 수준의 세부 사항을 처리해주는 프레임워크

**서비스 제공자 프레임워크**
- 제공자: 서비스의 구현체
- 프레임워크: 구현체들을 클라이언트에 제공하는 역할 -> 클라이언트와 구현체를 분리

그리고 3가지 컴포넌트가 존재한다.
- 서비스 인터페이스: 구현체의 동작 정의 -> `Connection`
- 제공자 등록 API: 제공자가 구현체를 등록할 때 사용 -> `DriverManager.registerDriver`
- 서비스 접근 API: 클라이언트가 서비스의 인스턴스를 얻을 때 사용 -> `DriverManager.getConnection`
- 추가로, 서비스 제공자 인터페이스: 서비스 인터페이스의 인스턴스를 생성하는 팩토리 객체 설명 -> `Driver` (ex. mysql, oracle, sqlserver 등)
  - 이게 없다면, 각 구현체를 인스턴스화할 때, 리플렉션을 사용해야 한다.

결과적으로, `getConnection()` 을 작성하는 시점에는 `Driver` 가 결정되지 않았지만, 실행 시점에는 `Driver` 가 할당되어 있다.

> **리플렉션**
> - 구체적인 클래스 타입을 알지 못해도 그 클래스의 메소드, 타입, 변수들에 접근할 수 있도록 해주는 자바 API

의존 객체 주입 프레임워크 또한 서비스 제공자이다.

```java
@Configuration
public class AppConfig {

    @Bean
    public HelloService helloService() {
        return new KoreanHelloService();
    }

}
```
- `HelloService`: 서비스 제공자 인터페이스
- `@Bean`: 서비스 구현체 등록

```java
public class App {
			
    public static void main(String[] args) {
        ApplicationContext ac = new AnnotationConfigApplicationContext(AppConfig.class);
        HelloService helloService = ac.getBean(HelloService.class);
        // HelloService에 hello() 라는 메소드가 구현되어 있다고 가정
        System.out.println(helloService.hello());
    }

}
```

- `getBean()`: 서비스 접근 API

# 단점 1. 정적 팩토리 메소드만 제공하는 클래스는 하위 클래스를 만들 수 없다.
상속을 위해서는 public이나 protected 생성자가 필요하기 때문이다.
- 따라서 상속이 필요하다면, 생성자와 함께 사용해야 한다는 말

# 단점 2. 정적 팩토리 메소드는 프로그래머가 찾기 어렵다.
생성자처럼 명확히 드러나진 않아 찾기 어려울 수 있다.
- 따라서 흔히 사용하는 명명 방식들을 정해두고 사용한다.

---

# 참고
- [아이템 1. 정적 팩토리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다](https://lxxjn0-dev.netlify.app/effective-java-item-01)