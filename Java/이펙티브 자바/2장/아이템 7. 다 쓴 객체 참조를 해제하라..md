**TOC**
- [스택 예제](#스택-예제)
- [null 처리가 필요한 경우](#null-처리가-필요한-경우)
  - [메모리 관리를 직접하는 클래스](#메모리-관리를-직접하는-클래스)
  - [캐시](#캐시)
  - [리스너 혹은 콜백](#리스너-혹은-콜백)

자바는 다른 언어와 달리 가비지 컬렉션을 통해, 메모리 관리에 대한 부담을 줄여준다.
- 하지만 그렇다고 해서, 절대 메모리에 대해 아예 신경쓰지 않아도 되는 것은 아니다.

# 스택 예제
```java
public class Stack {
    private Object[] elements;
    private int size = 0;
    private static final int DEFAULT_INITIAL_CAPACITY = 16;

    public Stack() {
        elements = new Object[DEFAULT_INITIAL_CAPACITY];
    }
    
    public void push(Object o) {
        ensureCapacity();
        elements[size++] = o;
    }
    
    public Object pop() {
        if (size == 0) throw new EmptyStackException();
        return elements[--size];
    }
    
    // 원소를 위한 공간을 적어도 하나 이상 확보
    // 배열 크기는 대략 두 배씩 늘린다.
    private void ensureCapacity() {
        if (elements.length == size) elements = Arrays.copyOf(elements, 2 * size + 1);
    }
}
```
- **메모리 누수 관점**에서, 해당 스택을 사용하는 프로그램을 오래 실행하다보면 
점차 **가비지 컬렉션 활동과 메모리 사용량이 늘어나 성능 저하를 초래**할 것이다.
  - 드물지만 심한 경우는 `디스크 페이징`이나 `OutOfMemoryError` 를 일으킬 수도 있다.

**메모리 누수**
```
일반적인 메모리 누수는 프로그램이 필요하지 않는 메모리를 계속 점유하고 있어 반환되지 않는 것이 누적되어 메모리가 낭비되는 현상
자바에서는, 더 이상 사용되지 않는 객체들이 가비지 컬렉터에 의해 회수되지 않고 계속 누적되는 현상
```

그렇다면 어떻게 메모리 누수가 일어나는 것일까?

이 코드에서는 스택이 커졌다가 줄어들 때, 스택에서 꺼내진 객체들을 프로그램에서 그 객체들을 더 이상 사용하지 않더라도, 가비지 컬렉터가 회수하지 않는다.
- 이 스택이 그 객체들의 **다 쓴 참조(obsolete reference)** 를 여전히 가지고 있기 때문이다.
  - 다 쓴 참조: 앞으로 다시 쓰지 않을 참조
  - 코드에서는 `elements` 배열의 **활성 영역**(인덱스가 size보다 작은 원소들로 구성) 밖의 참조들이 해당된다.

가비지 컬렉션에서는 의도치 않게 객체를 살려두는 **메모리 누수를 찾기 매우 까다롭다.**
- 객체 참조 하나를 살려두면, 가비지 컬렉터는 **그 객체뿐 아니라 그 객체가 참조하는 모든 객체(그리고, 그 참조 객체, 또 그 참조 객체 …)를 회수해가지 못한다.**
- 그렇기 때문에, 단 몇 개의 객체가 매우 많은 객체의 회수를 막을 수 있고, 이는 성능 악영향을 초래할 수 있다.

이에 대한 해법은 간단하다. 해당 참조를 다 썼을 때, **`null` 처리(참조 해제)** 하면 된다.
- `null` 처리를 하면, **GC의 대상**이 된다.
- 위 코드에서는 **스택에서 꺼내질 때가 참조를 다 쓴 경우**이다.

```java
public Object pop() {
    if (size == 0) throw new EmptyStackException();
		Object result = elements[--size];
		// 참조 해제
		elements[size] = null;
    return result;
}
```

- 다 쓴 참조를 `null` 로 처리하면, 또 다른 이점이 있다.
  - 만약 `null` 처리한 참조를 실수로 사용하려 하면, 프로그램은 즉시 `NullPointerException` 을 던지며 종료된다.
  - `null` 처리를 하지 않았다면 그대로 잘못된 일을 수행했을 것이다.
    
하지만 그렇다고 해서, 모든 객체를 다 쓰자마자 일일이 `null` 처리하는 것은 바람직하지 않다.

> **“객체 참조를 null 처리하는 일은 예외적인 경우여야 한다.”**

- 그래서 어떻게 하느냐?
- 그 참조를 담은 변수를 **유효 범위(scope) 밖으로 밀어내는 것**이다.
  - 즉, 변수의 범위를 최소가 되도록 정의하면, 자연스럽게 참조가 해제될 것이다.
    
# null 처리가 필요한 경우
그렇다면 `null` 처리는 언제 해야 할까? 아래는 null 처리가 필요한 경우들이다.

## 메모리 관리를 직접하는 클래스
`Stack` 클래스가 메모리 누수에 취약한 이유는 메모리를 직접 관리하기 때문이다!
- 위 스택은 **객체 자체가 아니라 객체 참조를 담는다.** 
  - `elements` 배열로 저장소 풀을 만들어 원소들을 관리한다.
  - 배열의 활성 영역에 속한 원소들이 사용되고, 비활성 영역은 쓰이지 않는다.
- 문제는, 가비지 컬렉터가 이를 알 방법이 없다.
  - 가비지 컬렉터 관점에서는 **두 원소 모두 똑같이 유효한 객체로 판단**한다.
  - 즉, 이러한 구분은 개발자만이 할 수 있기에, **개발자가 비활성 영역이 되는 순간 `null` 처리를 하여 가비지 컬렉터에게 이를 알려야 한다.**

> 일반적으로 **자기 메모리를 직접 관리하는 클래스**라면, 개발자는 **항상 메모리 누수에 주의**해야 한다.

## 캐시
객체 참조를 캐시에 넣고, 그 객체를 다 쓴 뒤에도, 캐시를 비워주지 않는 경우를 자주 볼 수 있다.

해법은 다음과 같다. 캐시 외부에서 키(key)를 참조하는 동안만 엔트리가 살아 있는 캐시가 필요한 상황이라면,
- `WeakHashMap` 을 사용해 캐시를 만들자.
- 다 쓴 엔트리는 그 즉시 자동으로 제거될 것이다.

**`WeakHashMap`**
```
약한 참조 해시 맵으로, 일반적인 HashMap과 달리, Key에 해당하는 객체가 더 이상 사용되지 않는다고 판단되면 제거하는 HashMap이다.
```

하지만 캐시를 만들 때, **보통은 캐시 엔트리의 이러한 유효 기간을 정의하는 것은 어렵다.**

- 따라서 **시간이 지날수록 엔트리의 가치를 떨어뜨리는 방식**을 사용한다.
  - 시간이 지날수록 쓰지 않는 엔트리를 확인하고 제거해야 한다.
  - `Scheduled ThreadPoolExecutor` 와 같은 백그라운드 스레드를 활용하거나, 캐시에 새 엔트리를 추가할 때 부수 작업으로 수행하는 방법이 있다.
  - `LinkedHashMap` 은 `removeEldestEntry()` 를 써서 후자의 방식을 구현한다.

## 리스너 혹은 콜백
- 클라이언트가 콜백을 등록만 하고 명확히 해지하지 않는다면, **콜백 지옥**에 들어가게 될 것이다.
  - 이럴 때 콜백을 약한 참조로 저장하면, 가비지 컬렉터가 즉시 수거해간다.
  - 약한 참조로 저장한다의 예는 **`WeakHashMap` 에 키로 저장하는 방법**이 있다.