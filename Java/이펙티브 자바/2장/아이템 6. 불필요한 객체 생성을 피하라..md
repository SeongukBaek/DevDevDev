**TOC**
- [불필요한 객체 생성을 피하는 법 1. 문자열 리터럴 사용](#불필요한-객체-생성을-피하는-법-1-문자열-리터럴-사용)
- [불필요한 객체 생성을 피하는 법 2. 불변 클래스에서의 정적 팩터리 메소드](#불필요한-객체-생성을-피하는-법-2-불변-클래스에서의-정적-팩터리-메소드)
- [불필요한 객체 생성을 피하는 법 3. 캐싱](#불필요한-객체-생성을-피하는-법-3-캐싱)
- [불필요한 객체를 생성 - 어댑터](#불필요한-객체를-생성---어댑터)
- [불필요한 객체를 생성 - 오토박싱](#불필요한-객체를-생성---오토박싱)
- [참고](#참고)

똑같은 기능의 객체를 매번 생성하는 것보다는 재사용하는 것이 더 빠르고 세련되어 나은 경우가 많다. 
- 특히 **불변 객체는 언제든 재사용이 가능**하다!
- 잘못된 예: 반복적인 `new String()` 사용

# 불필요한 객체 생성을 피하는 법 1. 문자열 리터럴 사용
`String` 의 경우, 문자열 리터럴을 사용해서 하나의 `String` 인스턴스를 사용하도록 하자.
- 같은 객체 재사용성 보장

# 불필요한 객체 생성을 피하는 법 2. 불변 클래스에서의 정적 팩터리 메소드
생성자 대신 정적 팩토리 메소드를 제공하는 **불변 클래스에서는 정적 팩토리 메소드를 사용해 불필요한 객체 생성을 피할 수 있다.**
- 이전에 언급한 `Boolean.valueOf(String)` 팩토리 메소드가 예이다.
- 또한 불변 객체만이 아니라, 가변 객체라 해도 사용 중에 변경되지 않을 것임을 안다면 재사용 가능하다.

# 불필요한 객체 생성을 피하는 법 3. 캐싱
생성 비용이 매우 비싼 객체의 경우, 캐싱하여 재사용하는 것을 권장한다.
- 근데 비싼 객체인지 어떻게 알 수 있을까?

예로, 정규표현식을 사용해 주어진 문자열이 유효한 로마 숫자인지 확인하는 메소드를 작성하는 코드이다.

```java
static boolean isRomanNumeral(String s) {
    return s.matches("^(?=.)M*(C[MD]|D?C{0,3})" + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");
}
```

- 위 방식의 문제는 `String.matches()` 를 사용한다는 것이다.
  - 이는 정규표현식으로 문자열 형태를 확인하는 가장 쉬운 방법이지만, 성능이 중요시되는 상황에서 반복적으로 사용하기에는 적합하지 않다.
    - 해당 메소드가 내부에서 만드는 정규표현식용 `Pattern` 인스턴스는 **일회용**이기에, 곧바로 **가비지 컬렉션**의 대상이 된다.
    - 이는 정규표현식에 해당하는 **유한 상태 머신**을 만들기에, 인스턴스 생성 비용이 높다.
        
**가비지 컬렉션**    
```
사용하지 않는 객체를 메모리에서 제거하는 작업
```
- 개발자가 직접 메모리를 해제해주지 않아도 되기에 Java의 장점 중 하나이다.
- JVM에서 수행
  - JVM의 메모리는 5개의 영역으로 나뉘는데, 그 중 GC는 Heap 메모리 영역만을 다룬다.

**유한 상태 머신**
```
유한한 개수의 상태를 가질 수 있는 추상 기계
```

따라서 성능의 개선을 위해,
- 필요한 정규표현식을 표현하는 (불변인) `Pattern` 인스턴스를 클래스 초기화(정적 초기화) 과정에서 직접 생성해 캐싱해두고,
- 나중에 `isRomanNumeral()` 가 호출될 때마다 이 인스턴스를 재사용하는 방법을 사용해야 할 것이다.

```java
public class RomanNumerals {
    private static final Pattern ROMAN = Pattern.compile("^(?=.)M*(C[MD]|D?C{0,3})" + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");

    static boolean isRomanNumeral(String s) {
        return ROMAN.matcher(s).matches();
    }
}
```

> **여기서 생각해볼 점.** 

만약 개선된 `isRomanNumeral()` 방식이 초기화 후, 호출되지 않는다면 쓸데없이 초기화된 꼴이다.
- 따라서 메소드가 처음 호출될 때 필드를 초기화하는 **지연 초기화(Lazy initialization)**를 사용해 불필요한 초기화를 없앨 수도 있다.
  - 하지만 코드가 복잡해지고, 성능 개선이 크게 이뤄지지 않을 수 있어 권장하지 않는다.

**지연 초기화**   
```
필드의 초기화 시점을 그 값이 처음 필요할 때까지 늦추는 기법이다.
```

# 불필요한 객체를 생성 - 어댑터
객체가 불변이라면 재사용해도 안전함이 명백하다.
- 하지만 예외가 있을 수 있다.
- 그 예로, 어댑터를 생각할 수 있다.

**어댑터**
```
한 클래스의 인터페이스를 사용하고자 하는 다른 인터페이스로 변환할 때 사용하는 객체
```
- 그리고 이를 사용한 어댑터 패턴으로, 인터페이스 호환성이 맞지 않아 같이 쓸 수 없는 클래스를 연관 관계로 연결해줄 수 있다.

어댑터는 **실제 작업은 뒷단 객체에 위임**하고, **제 2의 인터페이스 역할을 수행**하기에 뒷단 객체만 관리하면 된다.
- 뒷단 객체 외에는 관리할 상태가 없기에 **뒷단 객체 하나당 어댑터 하나씩** 만들어지면 충분하다.
- ex. `Map` 인터페이스의 `keySet()`: `Map` 객체 안의 키 전부를 담은 `Set 뷰(어댑터)`를 반환

# 불필요한 객체를 생성 - 오토박싱
불필요한 객체를 만들어내는 또 다른 예로 **오토박싱(auto boxing)**을 들 수 있다.
- **박싱**은 `기본 타입` 에 대응하는 `Wrapper 클래스`로 만드는 동작이고,
- **언박싱**은 `Wrapper 클래스`에서 `기본 타입`으로 변환하는 동작이다.

**Wrapper 클래스**
```
8개의 기본 타입에 해당하는 데이터를 객체로 포장해주는 클래스
```
- `Integer`, `Long`, `Float`, `Double`, `Boolean` 등이 있다.

**오토박싱**은 개발자가 **기본 타입과 박싱된 기본 타입을 섞어 쓸 때, 자동으로 상호 변환**해주는 기술이다.
- 이를 통해, **기본 타입과 박싱된 기본 타입의 구분을 흐리는 것 같지만, 완전히 없애는 것은 아니다.**

아래는 모든 양의 정수의 총합을 구하는 메소드로, `int` 는 충분히 크지 않아 `long` 을 사용하고 있다.

```java
private static long sum() {
    Long sum = 0L;
    for (long i = 0; i <= Integer.MAX_VALUE; i++)
        sum += i;

    return sum;
}
```

- 위 코드는 정확한 답을 내고는 있지만, 매우 느린 성능을 보인다.
  - `sum` 변수를 `long` 이 아닌 Wrapper 클래스인 `Long` 으로 선언하여 불필요한 `Long` 인스턴스가 약 **2^31**개나 만들어졌기 때문이다.

> **“박싱된 기본 타입보다는 기본 타입을 사용하고, 의도치 않은 오토박싱이 숨어들지 않도록 주의하자.”**

사실 요즘 JVM에서는 별다른 일을 하지 않는 작은 객체를 생성하고 회수하는 일이 크게 부담되진 않는다.

반대로, 아주 무거운 객체가 아니라면, 단순히 객체 생성을 피하고자 나만의 객체 풀을 만들지는 말자.

- 물론 만들어서 좋은 경우가 있긴 하지만,(DB 연결의 경우, 생성 비용이 높기에 재사용하는 것이 좋다.) 일반적으로는 메모리 사용량을 늘리고 성능과 가독성을 떨어뜨린다.
- 그리고 요즘 JVM의 GC는 최적화가 잘되어 가벼운 객체용을 다룰 때는 훨씬 빠르다.

**방어적 복사**
```
생성자를 통해 초기화 시에, 새로운 객체로 감싸 복사해주는 방법
```
- 이를 사용한다면, **외부에서 객체를 변경한다해도, 내부의 객체는 변경되지 않는다**.

# 참고
- [방어적 복사](https://tecoble.techcourse.co.kr/post/2021-04-26-defensive-copy-vs-unmodifiable/)