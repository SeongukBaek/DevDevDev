**TOC**
- [자바의 소멸자](#자바의-소멸자)
  - [수행 보장의 불확실성](#수행-보장의-불확실성)
  - [또 다른 문제점: 예외 이후의 처리, 성능](#또-다른-문제점-예외-이후의-처리-성능)
- [소멸자를 대신하는 방법](#소멸자를-대신하는-방법)
- [소멸자들은 언제 사용되는가?](#소멸자들은-언제-사용되는가)
  - [자원의 소유자가 close() 를 호출하지 않는 것에 대비한 안전망 역할](#자원의-소유자가-close-를-호출하지-않는-것에-대비한-안전망-역할)
  - [네이티브 피어와 연결된 객체에서의 역할](#네이티브-피어와-연결된-객체에서의-역할)
- [참고](#참고)

# 자바의 소멸자
자바는 두 가지 객체 소멸자를 제공한다. (`finalizer`, `cleaner`)
- 그 중 `finalizer` 는 예측할 수 없고, 상황에 따라 위험할 수 있어 일반적으로 불필요하다.
- 나름의 쓰임새가 있지만 기본적으로 “쓰지 말아야” 한다.
  - 자바 9에서는 이를 **사용 자제(deprecated) API**로 지정하고 `cleaner` 를 그 대안으로 소개했다.
- 하지만, `cleaner` 또한 여전히 예측할 수 없고, 느리고, 일반적으로 불필요하다.

**객체 소멸자**
```
객체가 가비지 컬렉터에 의해 제거될 때 호출되는 함수이다.
```
- 자원 누수를 막기 위해 JVM이 가비지 컬렉션을 수행할 때, 더 이상 사용하지 않는 자원에 대한 정리 작업을 위해 사용된다.

**자바의 finalizer와 cleaner vs. C++의 파괴자?**
- 이는 엄연히 다른 개념이다.
- C++에서의 파괴자는 **특정 객체와 관련된 자원을 회수하는 보편적인 방법**이다.
- 자바에서는 접근할 수 없게 된 객체를 회수하는 역할을 **가비지 컬렉터가 담당**하고, 개발자에게는 아무런 작업도 요구하지 않는다.
- C++의 파괴자는 비메모리 자원을 회수하는 용도로 쓰이고, 자바에서는 이를 `try-with-resources` 와 `try-finally` 를 사용해 해결한다.

## 수행 보장의 불확실성
`finalizer` 와 `cleaner` 는 **즉시 수행된다는 보장이 없다.** 
- 객체에 접근할 수 없게 된 후, `finalizer` 와 `cleaner` 가 실행되기까지 얼마나 걸릴지 알 수 없다.

> **즉, finalizer와 cleaner로는 제때 실행되어야 하는 작업은 절대 할 수 없다!**

이 소멸자들이 얼마나 빠르게 수행할지는 전적으로 **가비지 컬렉터의 알고리즘에 의존**하기에 천차만별이다.

이는 현업에서도 문제를 일으킨다.

클래스에 `finalizer` 를 달아두면, **그 인스턴스의 자원 회수가 제멋대로 지연**될 수 있다.
- 애플리케이션이 죽는 시점에 그래픽스 객체 수천 개가 `finalizer` 대기열에서 회수되기는 기다리고 있는 경우로 인해 `OutOfMemoryError` 가 발생한다거나 …
  - 이 경우는 `finalizer` 스레드가 다른 애플리케이션 스레드보다 우선순위가 낮아 실행될 기회를 얻지 못한 것이다. (일종의 starvation?)
  - 자바 언어 명세에서는 **어떤 스레드가 `finalizer` 를 수행할 지 명시하지 않아** 이 문제를 예방할 보편적인 방법은 없다.
- `cleaner` 는 자신을 수행할 스레드를 제어할 수 있다는 점에서 `finalizer` 보다는 낫다.
  - 하지만 여전히 **백그라운드에서 수행**되며, **가비지 컬렉터의 통제하**에 있어 수행 시점을 보장받지 못한다.

더 심한 점은, 자바 언어 명세에서는 **소멸자들의 수행 시점뿐만 아니라 수행 여부까지도 보장하지 않는다.** 
- 이는 즉, 접근할 수 없는 일부 객체에 대한 종료 작업을 전혀 수행하지 못한 채 프로그램이 중단될 수도 있다는 의미이다.
  - **이렇게 되면 메모리 누수가 발생하지 않나?**

> 따라서, 프로그램 생애주기와 상관없는, **상태를 영구적으로 수정하는 작업**에서는 절대 `finalizer` 나, `cleaner` 에 의존해서는 안된다.
> - ex. 데이터베이스 같은 **공유 자원의 영구 락(lock) 해제**를 소멸자에 맡겨서는 시스템이 서서히 멈출 것이다.

`System.gc` 나 `System.runFinalization` 메소드에 현혹되지 말자. 소멸자가 실행될 가능성을 높여줄 수는 있으나, 보장해주진 않는다.
- 이를 보장해주겠다는 2개의 메소드(`System.runFinalizersOnExit`  , `Runtime.runFinalizersOnExit`)가 있지만, 다음과 같은 이유로 사용하지 않도록 한다.

> It may result in finalizers being called on live objects while other threads are concurrently manipulating those objects, resulting in erratic behavior or deadlock.
> - 다른 쓰레드에서는 사용되고 있는, 즉 살아있는 개체까지도 정리해버릴 수 있는 본질적인 결함이 있다.

**`System.gc()`**
```
사용하지 않는 객체들을 재활용하기 위해 사용하는 함수
```

아래 참고를 확인하면, 매우 비효율적으로 동작한다는 것을 확인할 수 있다.

## 또 다른 문제점: 예외 이후의 처리, 성능
또한 **`finalizer` 동작 중 발생한 예외는 무시**되며, 처리할 작업이 남았더라도 그 즉시 종료된다.
- 그리고 다른 스레드가 이처럼 훼손된 객체를 사용하려 한다면, 어떻게 동작할지 예측할 수 없다.
- 보통의 경우, 잡지 못한 예외가 스레드를 중단시키고 스택 추적 내역을 출력하겠지만 `finalizer`에서는 이런 처리를 해주지 않는다.
  - `cleaner`는 그나마 스레드 통제권이 있어 이러한 문제는 발생하지 않는다.

**`finalizer`와 `cleaner`는 심각한 성능 문제도 동반한다.**
- `finalizer` 를 사용한 객체를 생성하고 파괴하는데 속도가 매우 느리다.
- **이는 `finalizer`가 가비지 컬렉터의 효율을 떨어뜨리기 때문이다.**

`finalizer`를 사용한 클래스는 `finalizer` 공격에 노출되어 심각한 보안 문제도 일으킬 수 있다.
- 생성자나 직렬화 과정에서 예외가 발생하면, **이 생성되다 만 객체**에서 악의적인 하위 클래스의 `finalizer`가 수행될 수 있게 된다.
- 이 `finalizer`는 정적 필드에 자신의 참조를 할당해 가비지 컬렉터가 수집하지 못하게 막을 수 있다.
  - 이제 이 일그러진 객체의 메소드를 호출해 **실행 로직에 없었던 작업을 수행할 수 있게 된다.**

> **객체의 생성을 막으려면 생성자에서 예외를 던지는 것만으로 충분하지만, `finalizer`가 있다면 그렇지도 않다.**

`final` 클래스들은 그 누구도 **하위 클래스를 만들 수 없어 안전**하겠지만, `final`이 아닌 클래스들은 아무 일도 하지 않는 `finalize()` 를 `final`로 선언해야 한다.

# 소멸자를 대신하는 방법
파일이나 스레드 등 종료해야 할 자원을 담고 있는 객체의 클래스에서 `finalizer`나 `cleaner`를 대신해줄 방법은 없을까.
- `AutoCloseable`을 구현해주고, 클라이언트에서 인스턴스를 다 쓰고 나면 `close()` 를 호출하면 된다.
  - 예외가 발생하더라도 제대로 종료될 수 있도록 `try-with-resources` 를 사용해야 한다.
- 추가적으로 **각 인스턴스에 자신이 닫혔는지를 추적**할 수 있도록, `close()` 에서 이 객체는 더 이상 유효하지 않음을 필드에 저장하고, 다른 메소드는 이 필드를 검사해서 객체가 닫힌 후 호출되었다면 `IllegalStateException` 을 던지도록 한다.

# 소멸자들은 언제 사용되는가?
그렇다면 도대체 이 소멸자들은 어디에 쓰는 것인가 ? 

적절한 쓰임새가 아마도 2가지 정도 있다.

## 자원의 소유자가 close() 를 호출하지 않는 것에 대비한 안전망 역할
- 소멸자가 즉시 호출되리라는 보장은 없지만, 클라이언트가 하지 않은 자원 회수를 늦게라도 해주는 것이 아예 안하는 것보단 낫기 때문이다.
- 이런 안전망 역할을 위한 `finalizer` 작성 시에는 그럴만한 가치가 있는지 생각해보고 작성하도록 하자.

## 네이티브 피어와 연결된 객체에서의 역할
**네이티브 피어**
```
일반 자바 객체가 네이티브 메소드를 통해 기능을 위임한 네이티브 객체
```

네이티브 메소드는 C/C++ 같은 네이티브 언어로 작성한 메소드를 말한다. `native` 키워드를 사용한다.
- 네이티브 피어는 **자바 객체가 아니기 때문에 가비지 컬렉터는 그 존재를 알 수 없고**, 자바 피어를 회수할 때, 함께 회수할 수 없다.
- 따라서, 명시적인 `cleaner` 나 `finalizer` 로 처리해줘야 한다.
  - 단 성능 저하를 감당할 수 있고, 네이티브 피어가 심각한 자원을 가지고 있지 않을때만 해당된다.
  - 그렇지 않은 경우는 `close()` 메소드를 사용해야 한다.

`cleaner`는 사용이 조금 까다롭다.
- 방(room)의 자원을 수거하기 전에 반드시 청소(clean)해야 한다고 가정하자.
  - `Room` 클래스는 `AutoCloseable`을 구현한다.
- 사실 자동 청소 안전망이 `cleaner`를 사용할지 말지는 순전히 내부 구현에 의존한다.
  - 즉, `finalizer`와 달리 `cleaner`는 클래스의 **public API**에 나타나지 않는다.

```java
import java.lang.ref.Cleaner;

public class Room implements AutoCloseable {
    private static final Cleaner cleaner = Cleaner.create();
    
		// 청소가 필요한 자원, 절대로 Room을 참조해서는 안된다.
    private static class State implements Runnable {
				// 방 안의 쓰레기 수
        int numJunkPiles;
        
        State(int numJunkPiles) {
            this.numJunkPiles = numJunkPiles;
        }

				// close()나 cleaner가 딱 한 번만 호출
        @Override
        public void run() {
            System.out.println("방 청소");
            numJunkPiles = 0;
        }
    }
    
		// 방의 상태, cleanable과 공유한다.
    private final State state;
    
		// cleanable 객체, 수거 대상이 되면 방을 청소한다.
    private final Cleaner.Cleanable cleanable;
    
    public Room(int numJunkPiles) {
        state = new State(numJunkPiles);
        cleanable = cleaner.register(this, state);
    }
    
    @Override
    public void close() throws Exception {
        cleanable.clean();
    }
}
```

- `static`으로 선언된 중첩 클래스(정적 중첩 클래스)인 `State`는 `cleaner`가 방 청소 시 수거할 자원들을 담고 있다.
- 현재는 `numJunkPiles` 필드만이 수거할 자원에 해당되지만, 더 현실적으로 만들기 위해서는 이 필드를 **네이티브 피어를 가리키는 포인터를 담은 `final long` 변수**여야 한다.
- `cleanable` 객체는 `Room` 생성자에서 `cleaner`에 `Room`과 `State`를 등록할 때 얻는다.

**정적 중첩 클래스**
```
중첩 클래스는 클래스 간 논리적인 그룹을 나타내기 위해 사용하고, static을 붙인 클래스이다.
외부 클래스에 static이 붙은 변수와 메소드만을 사용할 수 있다.
```
- 외부 클래스의 객체 없이도, 내부 클래스의 객체를 생성할 수 있다.
    
`run()` 이 호출되는 상황은 둘 중 하나다.
- 보통은 `Room`의 `close()` 를 호출할 때다.
  - 이 메소드에서 `Cleanable`의 `clean`을 호출하면, 이 메소드 안에서 `run()`을 호출한다.
- 혹은, 가비지 컬렉터가 `Room`을 회수할 때까지 클라이언트가 `close()`를 호출하지 않는다면, `cleaner`가 `State`의 `run()`을 호출해줄 것이다라는 바람을 가져보자.

**`State` 인스턴스는 절대 `Room` 인스턴스를 참조해서는 안된다.**
- 참조할 경우, 순환 참조가 발생해 가비지 컬렉터가 Room 인스턴스를 회수해갈 기회가 오지 않는다.
  - 정적이 아닌 중첩 클래스는 자동으로 바깥 객체의 참조를 갖는다!
  - 이와 비슷하게 람다 역시 바깥 객체의 참조를 갖기 쉽다.

**순환 참조**
```
서로 다른 객체가 서로를 참조하고 있는 현상, 즉 참조 관계에 순환이 발생하는 것이다.
```
    
`Room`의 `cleaner`는 **단지 안전망으로 쓰인다.** 클라이언트가 모든 `Room` 생성을 `try-with-resources` 블록으로 감쌌다면, **자동 청소는 전혀 필요하지 않다.**
- 그렇지 않은 경우라면, 객체 소멸 시점에서의 정리 작업은 보장되지 않는다.

# 참고
- https://codingdog.tistory.com/entry/java-systemgc-%ED%95%A8%EC%88%98-%EC%93%B0%EC%A7%80-%EB%A7%90%EC%95%84%EC%95%BC-%ED%95%A0-%EC%A0%95%EB%8F%84%EB%A1%9C-%EB%AC%B4%EA%B2%81%EB%8B%A4