**TOC**
- [점층적 생성자 패턴](#점층적-생성자-패턴)
- [자바빈즈 패턴](#자바빈즈-패턴)
- [빌더 패턴](#빌더-패턴)
- [참고](#참고)

---

선택적 매개변수가 많은 경우, 생성자이든 정적 팩토리 메소드이든, 적절한 대응이 어렵다.

# 점층적 생성자 패턴
이런 경우, 받는 매개변수를 늘려가는 방식인 **점층적 생성자 패턴**을 주로 사용했다.

> 매개변수가 많아질수록, 클라이언트 코드를 작성하거나 읽기 어려운 문제가 있다.

# 자바빈즈 패턴
이에 대한 대안으로, 매개변수가 없는 생성자(기본 생성자)로 객체를 만들고, `Setter` 를 통해 원하는 매개변수의 값들을 설정하는 방식이다.

인스턴스를 만들기 쉽고 더 읽기 쉬운 코드를 만들긴 했지만, 심각한 단점이 있다.
- 객체 하나를 만들기 위해 여러 메소드(Setter)를 호출해야 하고,
- 객체가 완전히 생성되기 전까지, 일관성이 무너진 상태이다.
  - 점층적 생성자 패턴에서는 생성자 호출 한 번으로 값이 모두 채워지고, 생성자에서 값의 유효성만 확인하면 일관성을 유지할 수 있다.
  - 하지만 자바빈즈 패턴의 경우는 각 메소드 호출을 통해 값이 차례로 채워지는 방식이기에 일관성이 무너지게 된다.

> **객체의 일관성?**
> - 클래스의 필수 필드가 채워진 상태를 일관성이 있는 객체라고 한다.

이러한 단점으로 인해 클래스를 불변으로 만들 수 없고, 스레드 안전성을 위해서는 추가 작업이 필요하다.
- 불변으로 만들 수 없는 이유는, 객체 생성이 한 번에 이뤄지지 않기 때문?
- 스레드 안전성: 여러 스레드에서 클래스 혹은 클래스의 객체에 동시에 접근해서 사용하더라도 정상적으로 동작하는 특성
  - 스레드 안전성을 위해서는 동시성을 고려하지 않아도 되는 **불변**이라는 특성이 가장 중요한데, 자바빈즈로는 이를 지킬 수 없다.

따라서 스레드 안전성을 위해, **Freezing**이라는 추가 작업이 필요하다.

```java
private boolean freeze = false;

public boolean isFreeze() {
    return freeze;
}

public void freeze() {
    this.freeze = true;
}
```
- 위와 같이 `isFreeze` 라는 추가 필드를 두고, 객체가 완성된 경우에 `freeze()` 를 호출해, 객체를 얼린다.
- 각 **Setter** 에서는 `isFreeze()` 를 호출하면서, 
  - 객체가 얼려진 상태인지 확인하고 얼려지지 않은 경우에만 동작하도록 한다.
- 하지만 추가 코드가 들어가야 하고, 이를 컴파일러가 잡아주지 않기 때문에, **런타임 오류에 취약**하다는 단점이 있다.

# 빌더 패턴
> 점층적 생성자 패턴(안전성 - 불변) + 자바 빈즈 패턴(가독성) => 빌더 패턴

필수 매개변수만으로 생성자 또는 정적 팩토리 메소드를 호출해 빌더 객체를 얻는다.
- 빌더 객체가 제공하는 일종의 Setter 들로 원하는 선택 매개변수를 설정한다.
  - 각 메소드들은 자기 자신, `this` 를 반환하기에 연쇄적 호출이 가능하다.
  - 이때 각 매개변수에 대한 유효성 검사를 수행할 수 있다.
- 마지막으로 `build()` 호출로, 객체를 얻는다.
  - 해당 메소드가 호출하는 생성자에서 여러 매개변수에 걸친 불변식을 검사하는 형태.

> 계층적으로 설계된 클래스와 함께 쓰기 좋다.

```java
// 피자의 다양한 종류를 표현하는 계층 구조의 최상위 추상 클래스
public abstract class Pizza {
    public enum Topping { HAM, MUSHROOM, ONION, PEPPER, SAUSAGE }
    final Set<Topping> toppings;
    
    abstract static class Builder<T extends Builder<T>> {
        // 기본값 세팅
        EnumSet<Topping> toppings = EnumSet.noneOf(Topping.class);

        public T addTopping(Topping topping) {
            // null이 아닌 경우 toppings에 추가
            toppings.add(Objects.requireNonNull(topping));
            return self();
        }
        
        abstract Pizza build();
        
        // 하위 클래스는 무조건 이 메소드를 오버라이드하여, this, 즉 자신을 반환하도록 해야 한다.
        // 여기서 자신은 오버라이딩 클래스 자신
        // 이를 통해 하위 클래스에서는 형변환없이 메소드 연쇄 지원
        protected abstract T self();
    }
    
    Pizza(Builder<?> builder) {
        toppings = builder.toppings.clone();
    }
}
```

- 하위 클래스들은 모두 자기 자신을 반환하도록 `self()` 를 재정의하고,
- `build()` 를 재정의해, 해당 클래스를 반환하는 생성자를 호출한다.
  - 여기서 정의된 상위 클래스 타입이 아닌, 그 하위 클래스 타입을 반환 => **공변 반환 타이핑**

```java
// Pizza
abstract Pizza build();

// 하위 클래스 A
@Override public A build() { return new A(this); }
```

안전성과 가독성을 모두 챙기는 패턴이지만, 아래의 단점이 존재한다.
- 빌더 클래스를 먼저 구현해야 한다.
- 코드가 길어서 매개변수가 4개 이상은 되어야 가치가 있다.

> lombok에서는, 빌더 패턴의 장황한 코드를 모두 대체해주는 `@Builder` 어노테이션을 제공한다.

# 참고
- [빌더 패턴(Builder pattern)을 써야하는 이유, @Builder](https://pamyferret.tistory.com/67)