정적 메소드와 정적 필드만 담은 클래스를 만들어 사용하고 싶은 경우가 있다. 

- 흔한 예로, `java.lang.Math` , `java.util.Arrays` 가 있다. (전부 `static`)
- 또한 `java.util.Collections` 처럼 특정 인터페이스를 구현하는 객체를 생성해주는 정적 메소드를 모아놓을 수도 있다.
- 그리고 `final` 클래스와 관련한 메소드를 모아놓을 때도 사용할 수 있다.
  - `final` 클래스를 상속해 하위 클래스에서 메소드를 넣는 건 불가능하기 때문이다.

**`final` 클래스는 왜 상속이 불가능할까? 언어 디자인에서의 규약인가?**
- `final` 키워드는 불변, 수정될 수 없음을 의미한다. 필드, 메소드에 이를 적용하면 재할당될 수 없음, 오버라이딩될 수 없음을 의미하고, 클래스에 적용하면 상속될 수 없음을 의미한다.
- [Why it is not possible to extend a final class in Java?](https://dev.to/amarlearning/why-it-is-not-possible-to-extend-a-final-class-in-java-5467)
    
정적 멤버만 담은 유틸리티 클래스는 인스턴스로 만들어 쓰려고 설계한 것은 아니지만, 컴파일러는 생성자를 명시하지 않은 클래스에 대해 **기본 생성자(매개 변수가 없는 `public` 생성자)**를 만들어 준다.
- 그리고 사용자는 생성자가 자동 생성된 것인지를 구분할 수 없다.

그렇다고 해서, 추상 클래스로 만드는 것으로는 인스턴스화를 막을 수 없다.
- 하위 클래스를 만들어 인스턴스화해버리면 끝이다.

> **인스턴스화?**
```
메소드와 변수를 모아놓은 것에 불과한 클래스를 사용할 수 있도록
해당 클래스 타입의 객체명을 선언하고 값을 넣어줘서
해당 클래스의 변수나 메소드를 사용 가능한 상태로 만드는 것
```

그렇다면 인스턴스화를 막는 방법은 무엇일까.

**컴파일러는 명시된 생성자가 없을 경우에만 기본 생성자를 만든다.** 
- 따라서 이를 못 만들도록 **다른 생성자를 만들어 준다.**
- **`private` 생성자를 추가**해 클래스의 인스턴스화를 막도록 한다.
    - 결국 이것도 생성자긴 하니까!

```java
public class UtilClass {
    
    private UtilClass() {
        throw new AssertionError();
    }
    
    // ...
}
```

생성자가 `private` 이므로 당연히! 외부에서는 접근 불가능하다.

이 방식은 **상속을 불가능하게 하는 효과**도 있다. 
- 왜냐면, **모든 생성자는 상위 클래스의 생성자를 호출**하는데, 위에서 말했듯 클래스 외부에서 접근이 불가능한 `private` 생성자이기 때문에 **하위 클래스(애초에 하위가 아니긴 한데)에서 호출할 수가 없다!**

> 근데 좀 웃기다. 생성자가 있는데 이를 호출하지 않을 것이다! 뭔가 불필요한 코드가 생겨버린 느낌이다.