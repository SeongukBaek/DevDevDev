**TOC**
- [용어 정리](#용어-정리)
- [제네릭 지원 전 컬렉션 사용](#제네릭-지원-전-컬렉션-사용)
  - [List vs. List](#list-vs-list)
  - [로 타입 대신 비한정적 와일드카드 타입](#로-타입-대신-비한정적-와일드카드-타입)
    - [로 타입과 비한정적 와일드카드 타입의 차이](#로-타입과-비한정적-와일드카드-타입의-차이)
  - [로 타입을 쓰지 말라는 규칙의 소소한 예외](#로-타입을-쓰지-말라는-규칙의-소소한-예외)

# 용어 정리
클래스와 인터페이스 선언에 **타입 매개변수**가 쓰였다?
- 타입 매개변수: 매개변수로 받아 타입을 결정한다고 해서 타입 매개변수라고 한다.
- 제네릭을 칭하는 또 다른 말.

→ **제네릭 클래스** or **제네릭 인터페이스**라고 한다. 그리고 이를 통틀어서 **제네릭 타입**라 한다. (어떤 클래스가 하나 이상의 타입 변수를 선언하고 있다면 이를 제네릭 클래스라고 한다.)
- Ex. `List` 인터페이스는 원소의 타입을 나타내는 타입 매개변수 `E`를 받는다.

각각의 제네릭 타입은 **일련의 매개변수화 타입(parameterized type)**을 정의한다. 예시로 이해하자면,
- `List<String>`은 원소의 타입이 `String`인 리스트를 뜻하는 매개변수화 타입이다.

→ 여기서 `String`은 위의 `E`에 해당하는 **실제 타입 매개변수**이다.

제네릭 타입을 정의하면, 그에 딸린 **로 타입(raw type)**도 함께 정의된다. 예로 들면, `List<E>`의 로 타입은 타입 매개변수가 전혀 사용되지 않은, 즉 `E`가 없는 `List`이다.
- 로 타입: 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않는 것.
- 이는 타입 선언에서 **제네릭 타입 정보가 전부 지워진 것처럼 동작**한다.

```java
class Test<T> {
    List<String> getList() {
        return Arrays.asList("string");
    }
    
    public static void main(String[] args) {
        Test t = new Test();

        for (String str : t.getList()) {
            System.out.println(str);
        }
    }
}
```
- 위 코드는 `t.getList()` 에서 컴파일 에러가 발생한다.
  - Test t가 로타입 변수이기 때문.
- [Java 제네릭 - Raw Type을 쓰면 안되는 이유](http://happinessoncode.com/2018/02/08/java-generic-raw-type/)  
  - 제네릭이 없던 시절의 코드와의 호환을 위한 방안이다… 역사의 흔적

# 제네릭 지원 전 컬렉션 사용
제네릭 지원 전 코드를 보면, 컬렉션의 로 타입을 사용했다. (`Collection stamps = …;`) 
- `Stamp` 타입만 취급한다고 가정했다.
- 하지만 여기에 `Stamp` 대신 `Coin`이라는 클래스를 넣는다고 해도 컴파일 시에는 오류를 일으키지 않는다.
- 런타임에서, 해당 컬렉션에서 `Coin` 클래스를 꺼낼 때, 예외가 발생하게 될 것이다.

```java
for (Iterator i = stamps.iterator(); i.hasNext()) {
		Stamp stamp = (Stamp) i.next(); // -> ClassCastException 발생!
		stamp.cancel();
}
```

> **오류는 가능한 한 발생 즉시, 이상적으로는 컴파일 시 발견하는 것이 좋다.**

위 예시에서는, 
- 오류가 발생하고 한참 뒤인 런타임 도중에 문제를 발견할 것이다.
- 하지만 문제를 겪는 코드(컬렉션에서 추출하는 코드)와 원인을 제공한 코드(컬렉션에 삽입하는 코드)가 물리적으로 떨어져 있을 가능성이 커지게 된다.

> **⇒ 제네릭을 활용하면 타입 선언 자체에 정보를 녹일 수 있다.**

```java
Collection<Stamp> stamps = ...;
```

위 코드로, 컴파일러는 `stamps`에 대한 인지(**어떤 클래스가 삽입되어야 하는지!**)를 하게 된다.
- 컴파일러는 **컬렉션에서 원소를 꺼내는 모든 곳에 보이지 않는 형변환을 추가**해, 의도한 코드들이 절대 실패하지 않음을 보장한다.

> **로 타입을 쓰면 제네릭이 안겨주는 안전성과 표현력을 모두 잃게 된다.**
- 그럼에도 불구하고 존재하는 이유는 앞서 설명했듯, **이전 버전의 자바 코드들과의 호환성**을 위해서이다.

## `List` vs. `List<Object>`
로 타입의 사용은 불가능하나, **`List<Object>`처럼 임의 객체를 허용하는 매개변수화 타입은 괜찮다!**
- 그렇다면 `List` 와 `List<Object>` 의 차이는 무엇일까?
- `List`는 제네릭 타입에서 완전히 타입 정보를 제거한 것이고, 
`List<Object>`는 모든 타입을 허용한다는 의미를 컴파일러에 전달한 것이다.

매개변수로 `List`를 받는 메소드에 `List<String>`을 넘길 수 있지만, `List<Object>`를 받는 메소드에서는 넘길 수 없다.
- **제네릭의 하위 타입 규칙때문!**

> 💡 `List<String>` 은 로 타입인 `List`의 하위 타입이지만, `List<Object>` 의 하위 타입은 아니다.
**⇒ 로 타입을 사용하게 되면, 타입 안전성을 잃게 된다.**

```java
List<String> strings = new ArrayList<>();
unsafeAdd(strings, Integer.valueOf(42));
String s = strings.get(0);

...

private static void unsafeAdd(List list, Object o) {
		list.add(o);
}
```

위 코드는 컴파일은 되지만, 로 타입인 `List` 를 사용해 경고가 발생한다.
- 그리고 실행하게 되면, `strings.get(0)`의 결과를 **자동으로 컴파일러가 형변환**하면서 `ClassCastException`이 발생한다.
- `unsafeAdd`의 매개변수를 `List<Object>`로 바꾸게 되면 컴파일 단계에서 에러가 발생한다.

> `List<String>`을 `List<Object>`로 바꿀 수 없다는 내용의 오류 발생! ⇒ **“불공변”**

## 로 타입 대신 비한정적 와일드카드 타입
로 타입의 타입 안전성을 잃게 되는 문제를 해결하기 위해, **비한정적 와일드카드 타입(`?`)**을 대신 사용하도록 하자.
- 실제 타입 매개변수가 무엇인지 신경쓰고 싶지 않을 경우 사용한다. (물음표 사용!)
- 예를 들어 제네릭 타입인 `Set<E>의` 비한정적 와일드카드 타입은 `Set<?>`이다.

### 로 타입과 비한정적 와일드카드 타입의 차이
- 와일드카드 타입은 안전하고, 로 타입은 안전하지 않다.
- 로 타입 컬렉션에는 아무 원소나 넣을 수 있어 타입 불변식을 훼손하기 쉽다.
- `Collection<?>` 에는 `null` 외의 어떤 원소도 넣을 수 없다.
  - 컴파일 단계에서 오류를 일으킨다.

어떤 원소도 넣을 수 없다 ?
- 어쨌든 컴파일러는 제 역할을 했다. 컬렉션의 타입 불변식을 훼손하지 못하도록 막은 것이다.
- `null` 외의 어떤 원소도 넣지 못하게 했으며, 컬렉션에서 꺼낼 수 있는 객체의 타입도 전혀 알 수 없게 했다.
- [추가 설명](https://snoop-study.tistory.com/113)

## 로 타입을 쓰지 말라는 규칙의 소소한 예외
**class 리터럴에는 로 타입을 써야 한다.**
- class 리터럴: 클래스, 인터페이스, 배열 타입들의 이름 또는 기본 타입, void 뒤에 "." 이 따라오고 class 토큰이 붙는 형식으로 구성된 표현법

**`instanceof` 연산자는 비한정적 와일드카드 타입 이외의 매개변수화 타입에는 적용할 수 없다.**
- 런타임에는 제네릭 타입 정보가 지워진다.
