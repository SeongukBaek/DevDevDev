**TOC**
- [가변인수 메소드와 제네릭](#가변인수-메소드와-제네릭)
- [약간의 모순](#약간의-모순)
- [자바 7 이후의 제네릭 가변인수 메소드](#자바-7-이후의-제네릭-가변인수-메소드)
	- [제네릭 varargs 매개변수 배열에 다른 메소드가 접근하도록 허용하지 말자.](#제네릭-varargs-매개변수-배열에-다른-메소드가-접근하도록-허용하지-말자)
- [정리](#정리)

# 가변인수 메소드와 제네릭
가변인수 메소드와 제네릭은 **자바 5**때 함께 추가되었다. (하지만 그렇다고 해서 잘 어울리는 것은 아니다.)

가변인수는 메소드에 넘기는 인수의 개수를 클라이언트가 조절할 수 있게 해준다.
- 하지만 구현 방식에 **허점이 존재**한다.
- 가변인수를 담기 위한 배열을 자동으로 생성하고, 이를 내부로 감추지 않고 **클라이언트에 노출하는 문제**가 발생한 것이다.

> **이로 인해 가변인수에 제네릭이나 매개변수화 타입이 포함되면, 알기 어려운 컴파일 경고가 발생한다.** 

이전 아이템(아이템 28)에서 **실체화 불가 타입은 런타임에는 컴파일타임보다 타입 관련 정보를 적게 담고 있음**을 다뤘다.
- 거의 모든 제네릭과 매개변수화 타입은 실체화되지 않는다.

따라서, 메소드 선언 시 **실체화 불가 타입으로 가변인수 매개변수를 선언**하면, **컴파일러가 경고**를 보낸다.
- `warning: [unchecked] Possible heap pollution from parameterized vararg type ~`
- 이와 같은 맥락으로 해당 메소드 호출에 대해서도 경고를 보낸다.

매개변수화 타입의 변수가 타입이 다른 객체를 참조하면, **힙 오염**이 발생한다.
- 힙 오염: JVM의 메모리 공간인 힙이 오염되는 현상으로, 컴파일이 끝난 이후 제네릭의 타입 매개변수 정보가 없어지기 때문에 런타임에서 발생하게 된다.
- 다른 타입 객체를 참조하는 상황에서는 컴파일러가 자동 생성한 형변환이 실패할 수 있으니, 제네릭 타입 시스템이 약속한 타입 안전성의 근간이 흔들려버린다.

```java
static void dangerous(List<String>... stringLists) {
	List<Integer> intList = List.of(42);
	Object[] objects = stringLists;
	objects[0] = intList; // 힙 오염 발생
	String s = stringLists[0].get(0); // ClassCastException
}
```

해당 메소드는 형변환하는 곳이 없는데도, 인수를 건네 호출하게 되면 `ClassCastException`을 던진다.
- 컴파일러가 생성한 형변환이 숨어 있다. (마지막 줄)

**→ 이처럼 타입 안전성이 깨지니, 제네릭 varargs 배열 매개변수에 값을 저장하는 것은 안전하지 않다.**

# 약간의 모순
제네릭 배열을 프로그래머가 직접 생성하는 건 불허, 제네릭 varargs 매개변수를 받는 메소드 선언은 가능한 이유?
- 후자가 실무에서 유용하기에, 이 모순을 수용!
- `Arrays.asList(T... a)` , `Collections.addAll(Collection<? super T> c, T... elements)`

# 자바 7 이후의 제네릭 가변인수 메소드
자바 7 이전에는 제네릭 가변인수 메소드를 사용하는 쪽에서 발생할 수 있는 경고에 대해 메소드 작성자가 따로 해줄 수 있는 일이 없었다.
- 하지만 자바 7에서 `@SafeVarargs` 어노테이션이 추가되어, 메소드 작성자가 클라이언트 측에서 발생하는 경고를 숨길 수 있게 되었다.
- 또한 이는 사용자로 하여금 해당 메소드가 타입 안전함을 보장한다는 것을 알려주기도 한다.

작성자는 그럼 해당 가변인수 메소드가 타입 안전한지 어떻게 알 수 있을까?
- 전달되는 가변인수가 순수하게 인수들을 전달하기만 하면, 이는 타입 안전함이 보장된다.
- 하지만, 예외는 있다.

```java
static <T> T[] toArray(T... args) {
	return args;
}
```
- 메소드가 반환하는 타입은 메소드에 인수를 넘기는 컴파일타임에 결정된다.
  - 하지만 위 메소드의 경우는 그 정보가 충분하지 않아 컴파일가 제대로 판단하기 어렵다.
- 따라서 그대로 반환하면, 힙 오염을 이 메소드를 호출한 쪽의 콜스택까지 전이시킬 수 있다.

## 제네릭 varargs 매개변수 배열에 다른 메소드가 접근하도록 허용하지 말자.
단 예외는 2가지가 있다.
- `@SafeVarargs` 로 명시된 다른 varargs 메소드에 전달하는 것은 안전하다.
- 해당 배열 내용의 일부 함수를 호출만 하는 일반 메소드에 넘기는 것은 안전하다.

예시
```java
@SafeVarargs
static <T> List<T> flatten(List<? extends T>... lists) {
	List<T> result = new ArrayList<>();
	for (List<? extends T> list : lists) {
		result.addAll(list);
	}
	return result;
}
```
- 어노테이션을 사용했기에, 선언하는 쪽과 사용하는 쪽 모두에서 경고가 발생되지 않는다.

# 정리
다음 두 조건을 만족하는 제네릭 varargs 메소드는 안전하다.
- varargs 매개변수 배열에 아무것도 저장하지 않는다.
- 그 배열 또는 복제본을 신뢰할 수 없는 코드에 노출하지 않는다.