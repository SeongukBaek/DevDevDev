**TOC**
- [함수 객체를 만드는 수단의 탄생](#함수-객체를-만드는-수단의-탄생)
- [함수형 인터페이스로서의 인정, 람다의 탄생](#함수형-인터페이스로서의-인정-람다의-탄생)
  - [점차 발전](#점차-발전)
- [람다를 너무 믿으면 안된다.](#람다를-너무-믿으면-안된다)

# 함수 객체를 만드는 수단의 탄생
함수 객체: 특정 함수나, 동작을 나타내는데 사용되는, 추상 메소드를 하나만 담은 인터페이스(드물게는 추상 클래스)

JDK 1.1의 등장으로, 이는 **익명 클래스**가 되었다.

```java
Collections.sort(words, new Comparator<String>() {
  public int compare(String s1, String s2) {
    return Integer.compare(s1.length(), s2.length());
  }
});
```
- Comparator 인터페이스: 정렬을 담당하는 추상 전략
- 익명 클래스로 구현된 함수: 문자열을 정렬하는 구체적인 전략

=> 하지만 위 코드는 너무 길어서, 함수형 프로그래밍에 적합하지 않다.

# 함수형 인터페이스로서의 인정, 람다의 탄생
자바 8에 와서, 추상 메소드 하나짜리 인터페이스는 람다식을 사용해 만들 수 있게 되어, 함수형 인터페이스라고 불리게 되었다.

람다: 익명 클래스와 개념은 비슷하지만, 훨씬 간결한 코드를 가진다.

```java
Collections.sort(words, (s1, s2) -> Integer.compare(s1.length(), s2.length()));
```
- 여기서는 람다, 매개변수, 반환 값의 타입에 대한 언급이 모두 없다.
  - **컴파일러가 대신 이 문맥을 파악해 타입 추론을 수행.**

> 타입을 명시해야 코드가 더 명확할 때만 제외하고는, 람다의 모든 매개변수 타입은 생략하자.

## 점차 발전
람다 자리를 대체하면 더 간결한 코드를 만들 수 있다.

**비교자 생성 메소드**
```java
Collections.sort(words,comparingInt(String::length));
```

**List 인터페이스에 추가된 sort()**
```java
words.sort(comparingInt(String::length));
```

위와 같이 언어 차원에서 람다를 지원하면서, 기존의 불필요하게 긴 코드들을 간결하게 만들 수 있었다.
- ex. 아이템 34에서 다룬 Operation 열거 타입 apply() 메소드 재정의

# 람다를 너무 믿으면 안된다.
람다는 이름이 없고, 문서화도 못한다.
- 따라서, 코드 자체만으로 동작을 설명해야하기에, 코드 줄 수가 많아지면 람다를 쓰지 말아야 한다.

> 세 줄을 넘어가지 않도록 하자. 가독성이 떨어진다.

익명 클래스를 대체하는 듯 보이지만, 아직 람다가 대체할 수 없는 곳이 있다.

**추상 클래스의 인스턴스를 만들 때, 람다를 쓸 수 없어 익명 클래스를 사용해야 한다.**
- 왜일까?
- 비슷하게 추상 메소드가 여러 개인 인터페이스의 인스턴스 생성 시에도 익명 클래스를 쓸 수 있다.

**람다는 자신을 참조할 수 없다.**
- 람다에서의 `this` 는 바깥 인스턴스를 가리킨다.
- 하지만 익명 클래스에서는 자신을 가리킨다.

=> 따라서 자신을 참조해야 하는 경우, 익명 클래스를 사용해야 한다.