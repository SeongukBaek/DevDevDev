**TOC**
- [표준 함수형 인터페이스의 등장](#표준-함수형-인터페이스의-등장)
  - [기본 인터페이스 6가지](#기본-인터페이스-6가지)
    - [Function 인터페이스 변형](#function-인터페이스-변형)
    - [인수를 2개씩 받는 변형 인터페이스 변형](#인수를-2개씩-받는-변형-인터페이스-변형)
    - [Supplier 인터페이스 변형](#supplier-인터페이스-변형)
- [표준 함수형 인터페이스를 사용하지 않아야 할 때 ?](#표준-함수형-인터페이스를-사용하지-않아야-할-때-)
  - [Comparator](#comparator)
  - [@FunctionalInterface](#functionalinterface)

# 표준 함수형 인터페이스의 등장
자바가 람다를 지원하면서 API 작성 모범 사례도 많이 바뀜.
- 템플릿 메소드 패턴 -> 함수 객체를 받는 정적 팩토리나 생성자 제공 방식으로 변경

**LinkedHashMap의 인스턴스 메소드인 removeEldestEntry() 예시**
- 여기서 알게 된 점
  - 인스턴스 메소드에서는 인스턴스 메소드 호출 가능.
  - 팩토리나 생성자 호출 시에는 해당 클래스의 인스턴스가 없는 상태.

따라서, 자기 자신을 함수 객체에 전달한 함수형 인터페이스를 아래와 같이 생성
```java
@FunctionalInterface interface EldestEntryRemovalFunction<K, V> {
  boolean remove(Map<K, V> map, Map.Entry<K, V> eldest);
}
```
- 하지만 이미 같은 모양의 인터페이스가 자바 표준에 존재.(`java.util.function`)

> 필요한 용도에 맞는 게 있다면, 직접 구현하지 말고 표준 함수형 인터페이스를 활용하라.

해당 패키지에는 43개의 인터페이스가 존재
- 이 중 기본 인터페이스인 6개만 기억하면 나머지는 유추 가능.

## 기본 인터페이스 6가지
**Operator 인터페이스**
- 인수가 1개인 `UnaryOperator` , 2개인 `BinaryOperator` 로 나뉨.
- 반환 값과 인수의 타입이 같은 함수

**Predicate 인터페이스**
- 인수 하나를 받아 boolean 반환하는 함수

**Function 인터페이스**
- 인수와 반환 타입이 다른 함수

**Supplier 인터페이스**
- 인수를 받지 않고, 값을 반환하는 함수

**Consumer 인터페이스**
- 인수를 하나 받고, 반환 값은 없는(소비하는) 함수

위 기본 인터페이스들은 기본 타입인 `int`, `long`, `double` 용으로 변형이 발생.
- `IntPredicate`, `LongBinaryOperator`, ~~~
- `Function` 인터페이스의 경우는 아래와 같이 반환 타입이 매개변수화!
  - `LongFunction<int[]>` -> `long` 인수를 받아 `int[]` 반환하는 함수.

### Function 인터페이스 변형
기본 타입을 반환하는 변형이 9개 존재
- 6개 -> 입력과 결과 타입이 모두 기본 타입 => `SrcToResult` 접두어 사용 (`LongToIntFunction`, ~~~)
- 3개 -> 입력이 객체 참조 => `ToResult` 접두어 사용 (`ToLongFunction<int[]>`, ~~~)

### 인수를 2개씩 받는 변형 인터페이스 변형
**`BiPredicate<T, U>`**

**`BiFunction<T, U, R>`**
- 여기서는 또 기본 타입을 반환하는 3가지 변형 존재

**`BiConsumer<T, U>`**
- 객체 참조와 기본 타입 하나를 받는 변형 존재
  - `ObjIntConsumer`, `ObjLongConsumer`, `ObjDoubleConsumer`

### Supplier 인터페이스 변형
`BooleanSupplier` : `boolean` 을 반환하는 Supplier 인터페이스

> 표준 함수형 인터페이스 대부분 기본 타입만 지원. 따라서 박싱된 기본 타입을 넣어 쓰지 말자.

# 표준 함수형 인터페이스를 사용하지 않아야 할 때 ?
필요한 용도에 맞는 게 없는 경우!
- ex. 매개변수 3개를 받는 Predicate, 검사 예외를 던지는 경우, ~~~

그런데 구조적으로 동일한 표준형 함수 인터페이스가 있어도 직접 작성해야 하는 경우가 있다.

## Comparator<T>
구조적으로는 `ToIntBiFunction<T, U>` 와 동일하나, 왜 새로 작성되었을까?

1. API에서 굉장히 자주 사용되는데, Comparator 라는 새로운 이름이 해당 용도를 훌륭히 설명.
2. 구현하는 쪽에서 반드시 지켜야 할 규약이 잘 명시.
3. 비교자들을 변환하고 조합해주는 유용한 디폴트 메소드가 존재.

정리하면 아래의 조건으로 나타낼 수 있는데, 이 중 하나 이상 만족한다면, 새로운 함수형 인터페이스를 작성해서 사용하는 것이 나을 수 있다.
- 자주 쓰이며, 이름 자체가 용도를 명확히 설명
- 반드시 따라야 하는 규약 존재
- 유용한 디폴트 메소드 제공

## @FunctionalInterface
해당 어노테이션을 사용하는 이유
1. 해당 인터페이스가 람다용으로 설계된 것임을 명시
2. 해당 인터페이스가 추상 메소드를 오직 하나만 가지고 있어야 컴파일될 수 있음을 명시
3. 유지보수 과정에서 누군가 실수로 메소드를 추가하지 못하도록 방지

> **즉, 위에서 알려준 조건 중 하나 이상 만족해, 직접 만든 함수형 인터페이스를 사용한다면, 해당 어노테이션을 사용하자.**