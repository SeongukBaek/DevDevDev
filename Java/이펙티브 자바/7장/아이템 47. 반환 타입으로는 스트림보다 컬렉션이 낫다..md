**TOC**
- [스트림 등장 이전.](#스트림-등장-이전)
  * [스트림을 반복하는 우회법](#스트림을-반복하는-우회법)
  * [어댑터 메소드 생성으로 우회](#어댑터-메소드-생성으로-우회)
- [컬렉션 반환 시, 예외](#컬렉션-반환-시-예외)

# 스트림 등장 이전.
스트림이 등장하기 전에는 일련의 원소를 반환하는 메소드의 반환 타입은 **컬렉션 인터페이스가 기본**인 타입들.
- 하지만 스트림이 등장하면서 이 선택이 복잡한 일이 되어버림.

원소 시퀀스를 반환할 때는 당연히 스트림을 사용해야 한다.
- 하지만 스트림은 반복을 지원하지 않기에, 스트림과 반복을 상황에 따라 적절히 선택해야 한다.

> `Stream` 인터페이스는, `Iterable` 인터페이스의 추상 메소드를 모두 포함하고, 해당 인터페이스가 정의한 방식대로 동작한다.
> - 그럼에도 `for-each` 로 스트림을 반복하지 못하는 이유는, `Iterable` 을 확장하지 않아서이다.

## 스트림을 반복하는 우회법
```java
for (ProcessHandle ph : ProcessHandle.allProcesses()::iterator) {
    // do something
}
```
- `Stream.iterator()` 에 메소드 참조를 건네는 방식으로 우회 시도 => 컴파일 오류 발생
  - `매개변수화된 Iterable` 로 형변환 필요
  - 위에서는 (`Iterable<ProcessHandle>`) 추가
- 이러한 방식은 난잡하고 직관적이지 않다.

## 어댑터 메소드 생성으로 우회
```java
public static <E> Iterable<E> iterableOf(Stream<E> stream) {
    return stream::iterator;
}

for (ProcessHandle ph : iterableOf(ProcessHandle.allProcesses())) {
    // do something
}
```

API의 반환방식에 따라, 이를 사용하는 프로그래머의 추가적인 작업이 필요할 수 있다.
- `Iterable` 만 반환하는 경우, 이를 스트림 파이프라인에서 처리하려는 프로그래머는 추가적인 작업이 필요하다.
  - 이에 대해서도, 위에서의 어댑터 메소드와 같이, `Iterable` 을 받아, `Stream` 을 반환하는 어댑터 메소드를 생성해 사용할 수 있다.
 
> 공개 API 를 작성하는 경우, 해당 API 를 사용하는 사람들을 모두 고려하자.

**Collection 인터페이스**
`Collection` 인터페이스는
- `Iterable` 의 하위 타입
- `stream()` 제공
- **반복과 스트림 모두 지원.**

**=> 따라서, 원소 시퀀스를 반환하는 공개 API의 반환 타입에는 `Collection` 이나 그 하위 타입을 사용하자.**
- 하지만, 단지 컬렉션을 반환한다는 이유로 덩치 큰 시퀀스를 메모리에 올리지 않도록 주의하자.

# 컬렉션 반환 시, 예외
반환할 시퀀스가 크지만, 표현이 간결하다면 **전용 컬렉션**을 구현하자.
- `AbstractCollection` 을 활용해 전용 컬렉션을 구현할 수 있다.
- 이 경우, `Iterable` 용 메소드 외에, `contains()` , `size()` 메소드만 더 구현하면 된다.
- 만약, 해당 메소드를 구현할 수 없다면 **컬렉션 대신 스트림이나 `Iterable` 을 반환**하도록 하자.
  - 혹은, 구현하기 좀 더 쉬운 쪽을 선택하자. (물론 메소드 사용자의 편의에 따라 선택해야 함.)
