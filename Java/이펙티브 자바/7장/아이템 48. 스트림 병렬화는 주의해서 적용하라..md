**TOC**
- [동시성 프로그래밍](#동시성-프로그래밍)
   * [parellel을 함부로 사용한 결과](#parellel을-함부로-사용한-결과)
- [병렬화로 효과보기 위한 방법 - 스트림 소스](#병렬화로-효과보기-위한-방법-스트림-소스)
- [병렬화로 효과보기 위한 방법 - 종단 연산의 동작 방식](#병렬화로-효과보기-위한-방법-종단-연산의-동작-방식)
- [병렬화로 효과보기 위한 방법 - spliterator 메소드 재정의, 성능 테스트](#병렬화로-효과보기-위한-방법-spliterator-메소드-재정의-성능-테스트)
- [스트림을 잘못 병렬화하는 경우](#스트림을-잘못-병렬화하는-경우)
- [스트림 병렬화 도입 전 해봐야 하는 고민](#스트림-병렬화-도입-전-해봐야-하는-고민)

# 동시성 프로그래밍
자바는 동시성 프로그래밍 측면에서 항상 앞서가는 언어.
- 첫 릴리즈 : 스레드, 동기화, `wait`/`notify`
- 자바 5 : 동시성 컬렉션 라이브러리, 실행자 프레임워크 지원
- 자바 7 : 고성능 병렬 분해 프레임워크인 포크-조인 패키지 추가
- 자바 8 : parallel 메소드를 통한 파이프라인 병렬 실행 스트림 지원

> 언어 측면에서 이와 같이 지원하지만, 동시성 프로그래밍을 올바르고 빠르게 작성하는 것은 어렵다.

**동시성 프로그래밍에서 중요한 것**
- 안전성 유지
- 응답 가능 상태 유지

## parellel 을 함부로 사용한 결과
```java
// 아이템 45. 메르센 소수
```
- 속도 향상을 위해 스트림 파이프라인의 `parallel()` 호출 가정.
  - 결과 : CPU 사용량 90%
 
**원인: 스트림 라이브러리가 이 파이프라인을 병렬화하는 방법을 찾아내기 못했기 때문.**

> 데이터 소스가 `Stream.iterate` 거나, 중간 연산으로 `limit` 를 사용하면, 파이프라인 병렬화로는 성능 개선을 기대할 수 없다.

파이프라인 병렬화는 limit 사용과 관련해서 아래의 가정을 취한다.
- '`limit` 를 다룰 때, CPU 코어가 남는다면, 원소를 몇 개 더 처리한 후, 제한된 개수 이후의 결과를 버려도 아무런 해가 없다'
- 위 가정은, 원소 하나를 계산하는 비용이 대략 이전까지의 원소 전부를 계산한 비용을 합친 것만큼 드는 경우, 파이프라인 병렬화가 제 기능을 못하게 만든다.

> **스트림 파이프라인을 마구잡이로 병렬화하면 안된다.**

# 병렬화로 효과보기 위한 방법 - 스트림 소스
스트림의 소스가 `ArrayList`, `HashMap`, `HashSet`, `ConcurrentHashMap` 의 인스턴스거나, `배열`, `int`, `long` 범위일 때, 효과가 좋다.
- 이유 : **위 자료구조들은 모두 데이터를 원하는 크기로 정확하고, 손쉽게 나눠, 일을 다수의 스레드에 분배하기 좋기 때문.**
- 나누는 작업 -> `Spliterator` 인스턴스

또 다른 이유로, **위 자료구조들은 모두 원소들을 순차적으로 실행할 때의 참조 지역성이 뛰어나다.**
- 이웃한 원소의 참조들이 메모리에 연속해서 저장!
  - 하지만, 참조가 가리키는 실제 객체가 메모리 상에서 멀리 떨어지게 되면, 참조 지역성이 낮다.
  - 이 경우, 스레드는 주 메모리에서 캐시 메모리로 데이터 전송되는 동안 IDLE 하게 된다.
- **기본 타입의 배열**은, 참조가 아닌 데이터 자체가 메모리에 연속해서 저장되기에, 참조 지역성이 가장 뛰어나다.

# 병렬화로 효과보기 위한 방법 - 종단 연산의 동작 방식
> 종단 연산의 작업량이 파이프라인 전체 작업에서 얼마나 적은 비중을 차지하는지, 순차적인 연산인지를 고려해야 한다.

종단 연산 중 병렬화에 가장 적합한 연산은 **축소**
- 이는 파이프라인에서 만들어진 모든 원소를 하나로 합치는 작업.
  - Stream의 `reduce` 중 하나, `min`, `max`, `count`, `sum` 같이 완성된 형태로 제공되는 메소드 중 하나 선택.
  - 또한, `anyMatch`, `allMatch`, `noneMatch` 처럼 조건에 맞는 경우 바로 반환되는 메소드도 적합

> 하지만 가변 축소를 수행하는 `Stream.collect` 는 컬렉션들을 합치는 부담으로 인해, 적합하지 않은 종단 연산이다.

# 병렬화로 효과보기 위한 방법 - spliterator 메소드 재정의, 성능 테스트
직접 만든 Stream, Iterable, Collection 으로도 병렬화의 효과를 보고 싶다면, 위에서 다뤘던 Spliterator 인스턴스를 가져오는 spliterator() 를 재정의하고, 결과 스트림의 병렬화 성능을 테스트해야 한다.

# 스트림을 잘못 병렬화하는 경우
성능 저하 뿐만 아니라, 결과 자체가 잘못되거나 오동작할 수 있다. => **안전 실패**

`Stream` 명세는 사용되는 함수 객체에 대한 엄중한 규약 정의 (안전 실패를 막고자)
- ex. Stream.reduce 연산에 건네지는 `accumulator`, `combiner` 함수는 반드시 결합법칙을 만족하고, 간섭받지 않고, 상태를 갖지 않아야 한다.

# 스트림 병렬화 도입 전 해봐야 하는 고민
**스트림 병렬화는 오직 성능 최적화 수단이다.**
- 변경 전후로, 성능을 테스트해서, 병렬화의 사용 가치가 있는지 확인해야 한다.
- 잘못된 파이프라인 하나가 시스템의 다른 부분까지도 영향을 미칠 수 있음을 고려해야 한다.

> 스트림 병렬화를 자주 할 일은 없지만, 조건이 잘 맞는다면 parallel 호출 한 번으로, 거의 프로세서 코더 수에 비례하는 성능 향상을 누릴 수 있다.
