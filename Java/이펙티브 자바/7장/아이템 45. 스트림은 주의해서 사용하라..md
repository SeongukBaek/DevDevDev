**TOC**
- [스트림 등장](#스트림-등장)
- [스트림 파이프라인](#스트림-파이프라인)
  - [지연 평가](#지연-평가)
- [스트림보다 코드 블록이 유용한 경우](#스트림보다-코드-블록이-유용한-경우)
- [반대로 스트림이 안성맞춤인 경우](#반대로-스트림이-안성맞춤인-경우)
  - [스트림으로 처리하기 어려운 일](#스트림으로-처리하기-어려운-일)

# 스트림 등장
스트림 API는 자바 8에서 등장
- 다량의 데이터 처리 작업을 돕기 위함.
- 추상 개념 중 핵심 2가지
  - **스트림** : 데이터 원소의 유한 혹은 무한 시퀀스
  - **스트림 파이프라인** : 이 원소들로 수행하는 연산 단계 표현
  - 스트림 원소 종류 : 컬렉션, 배열, 파일, 정규표현식 패턴 매처, 난수 생성기, 다른 스트림 등
  - 스트림 데이터 원소 : 객체 참조, 기본 타입 값 (int, long, double)

**플루언트 API**
- 스트림 API는 메소드 연쇄를 지원.
- 파이프라인의 모든 호출을 연결해 하나의 표현식으로 완성 가능.
- 또한 파이프라인 여러 개를 연결해 하나의 표현식으로 완성 가능.
 
# 스트림 파이프라인
소스 스트림에서 시작해 종단 연산으로 끝나며, 그 사이에 하나 이상의 중간 연산이 있을 수 있다.
- 각 중간 연산은 스트림을 특정 방식으로 변환.
  - ex. 각 원소에 함수 적용, 원소 필터링
- 변환된 스트림은 기존 스트림의 원소 타입과 같을 수도 있고, 다를 수도 있음.
- 종단 연산은 마지막 중간 연산이 내놓은 스트림에 마지막 연산을 적용.
  - ex. 정렬 후 컬렉션에 담기, 특정 원소 하나 선택, 모든 원소 출력
- 파이프라인은 순차 수행. 병렬도 가능(`parallel()` 호출).
 
## 지연 평가
스트림 파이프라인은 [지연 평가](https://inpa.tistory.com/entry/LODASH-%F0%9F%93%9A-%EC%A7%80%EC%97%B0-%ED%8F%89%EA%B0%80-%EC%9B%90%EB%A6%AC-lodash%EB%8A%94-%EC%98%A4%ED%9E%88%EB%A0%A4-%EC%84%B1%EB%8A%A5%EC%9D%B4-%EC%A2%8B%EC%9D%84-%EC%88%98-%EC%9E%88%EB%8B%A4)(lazy evaluation, 계산이 필요한 시점까지 계산을 미루는 것)된다.
- 종단 연산 호출 시 평가된다.
  - 따라서 종단 연산에 사용되지 않는 데이터 원소는 평가 대상이 아니다.

> 따라서 종단 연산이 없는 파이프라인은 아무 일도 하지 않는 것이다.

> 지연 평가 <-> 엄격한 평가

```java
// 사용자가 지정한 문턱값보다 원소 수가 많은 아나그램 그룹 출력 예시
...
Map<String, Set<String>> groups = new HashMap<>();
try (Scanner s = new Scanner(new File(...))) {
    while (s.hasNext()) {
        String word = s.next();
        groups.computeIfAbsent(alphabetize(word), (unused) -> new TreeSet<>()).add(word);
    }  
}
...
```
- 위 코드는 맵 안에 키가 있는지 찾은 다음, 있으면 단순히 그 키에 매핑된 값을 반환
- 키가 없으면 건네진 함수 객체에 키를 적용해 값을 계산하고, 그 키와 값을 매핑하고 계산된 값 반환

=> `computeIfAbsent()` 를 사용해 각 키에 다수의 값을 매핑하는 맵을 쉽게 구현

> **스트림을 과용하면 프로그램이 읽거나 유지보수하기 어려워진다.** 적절히 활용해 깔끔하고 명료한 코드를 작성하자.
> - 또한, 스트림 내에서의 변수나 람다에서의 매개변수 이름을 잘 지어서, 가독성을 유지하자.

> char 값들을 처리할 때는 스트림을 삼가는 편이 낫다.

# 스트림보다 코드 블록이 유용한 경우
- 코드 블록에서는 범위 안의 지역 변수를 읽고, 수정할 수 있다.
  - **람다에서는 `final`, `effectively final` 인 변수만 읽을 수 있고, 지역 변수 수정은 불가능하다.**
- 코드 블록에서는 return 문을 사용해 메소드를 탈출하거나, break, continue 문으로 블록에서의 코드 흐름을 제어할 수 있고, 메소드 선언에 명시된 검사 예외를 던질 수 있다.
  - **람다는 아무것도 못한다.**

# 반대로 스트림이 안성맞춤인 경우
- 원소들의 시퀀스를 일관되게 변환
- 원소들의 시퀀스를 필터링
- 원소들의 시퀀스를 하나의 연산을 사용해 결합
- 원소들의 시퀀스를 컬렉션에 모으기
- 원소들의 시퀀스에서 특정 조건을 만족하는 원소 찾기

## 스트림으로 처리하기 어려운 일
한 데이터가 파이프라인의 여러 단계를 통과할 때, 이 데이터의 각 단계에서의 값들에 동시 접근
- 스트림 파이프라인의 구조 때문 -> 한 값을 다른 값에 매핑하고 나면, 기존의 값은 잃는 구조.
- 매핑을 거꾸로 수행하는 방법으로 이전 스트림의 값을 얻을 수는 있다.

**ex. 메르센 소수 코드**
- 메르센 소수를 구할 때 사용되는 지수 정보를 출력하기 원하는 상황
- 출력은 종단 연산에서 발생하기에, 초기 스트림에서 사용되는 지수 정보에 접근 불가.
- 이때, 종단 연산에서, 매핑을 거꾸로 수행하여 지수를 계산할 수 있다.
  - 지수 정보는 결과값인 숫자를 이진수로 변환하고 비트 수를 세면 되기에, 가능.

> 하지만 과연 이렇게 결과로부터 이전 스트림에서 사용한 값을 계산해낼 수 있는 경우가 많을까?

> 스트림과 반복은 비슷한 결과를 내긴 하지만, 코드는 완전히 다르다. 따라서 각자 이해하기 쉽게, 그리고 상황에 맞게 코드를 작성하는 것이 중요하다.
