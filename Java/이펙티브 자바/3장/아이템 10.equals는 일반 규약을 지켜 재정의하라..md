**TOC**
- [equals를 재정의하지 않아도 되는 상황](#equals를-재정의하지-않아도-되는-상황)
- [equals를 재정의해야 하는 상황](#equals를-재정의해야-하는-상황)
  - [값 클래스](#값-클래스)
- [equals() 재정의 규약](#equals-재정의-규약)
  - [양질의 equals() 구현 방법](#양질의-equals-구현-방법)
    - [마지막 주의사항](#마지막-주의사항)

# equals를 재정의하지 않아도 되는 상황
`equals()`는 재정의하기 쉬워 보이지만 그만큼 문제가 발생하기도 쉽다. 따라서 아래 상황 중 하나에 해당한다면, 아예 재정의하지 않는 것이 문제를 피하는 가장 쉬운 방법이다.
- 각 인스턴스가 본질적으로 고유하다.
- 인스턴스의 논리적 동치성을 검사할 일이 없다.
- 상위 클래스에서 재정의한 `equals`가 하위 클래스에도 딱 들어맞는다.
- 클래스가 `private`이거나 `package-private`이고, `equals()`를 호출할 일이 없다.
  - 실수로라도 호출되는 것을 막기 위한다면, `AssertionError()`를 던지도록 재정의해버리자.

# equals를 재정의해야 하는 상황
**객체 식별성**이 아니라 **논리적 동치성**을 확인해야 하는데, 상위 클래스의 `equals`가 논리적 동치성을 비교하도록 재정의되지 않았을 때이다.

**객체 식별성**
```
객체 각각이 서로 다른 특징을 가지고 있는 것을 말한다.
```
    
**논리적 동치성**
```
참조 타입 변수를 비교하는 것으로, 비교할 핵심 값을 정하고, 
핵심 값을 비교하여 두 객체가 동등하다면 논리적 동치성을 가진다고 한다.
```

```java
String s1 = "ten";
String s2 = "ten";
String s3 = new String("ten");
String s4 = new String("ten");

// s1.equals(s2) -> true
// s2.equals(s3) -> true
// s3.equals(s4) -> true
```

- 서로 다른 객체를 가리키더라도, 그 객체들이 가진 상태 값이 논리적으로 같다면, 논리적 동치성을 가진다.

```java
StringBuilder sb1 = new StringBuilder("ten");
StringBuilder sb2 = new StringBuilder("ten");

// sb1.equals(sb2) -> false
```

- 둘 다 같은 `ten`을 인자로 받지만, 값이 `false`이다.
- 이유는 `StringBuilder`는 `equals()`를 오버라이딩하지 않아, `Object`의 `equals()`를 그대로 사용하고, 이는 **동일성만 체크하는 메소드**이므로 결과가 `false`이다.

**`equals()` vs. `==`**

**equals()**
```
논리적 동치성을 비교한다. 객체의 값이 같은지를 확인한다.
```

**==**
```
항등 연산자로 객체 인스턴스의 주소 값을 비교한다.
```

## 값 클래스
equals를 재정의해야 하는 상황 중, 주로 값을 표현하는 `Integer`, `String` 같은 클래스가 해당되는데, 두 값 객체를 `equals`로 비교하는 개발자는 객체가 같은지가 아니라, 그 값이 같은지를 알고 싶어 할 것이다.
- 따라서 **논리적 동치성을 확인하도록 재정의**하여 값 클래스를 사용하는 클래스에서도 활용할 수 있도록 한다.
- 값 클래스라 해도, **인스턴스 통제 클래스**라면, 즉 같은 인스턴스가 하나만 만들어지는 것을 보장하는 클래스라면 재정의할 필요가 없다.
  - `Enum`이 여기에 해당한다.
  - 이 경우, 객체 식별성 = 논리적 동치성

# equals() 재정의 규약
`Object` 명세에서 `equals()`는 **동치관계를 구현**한다고 한다. 여기서 동치관계는 무엇을 의미할까?

- 이는 집합을 서로 같은 원소들로 이뤄진 부분집합으로 나누는 연산이다.
- 이 부분집합을 **동치류**라 한다.

> `equals()`가 쓸모있으려면 모든 원소가 같은 동치류에 속한 어떤 원소와도 서로 교환할 수 있어야 한다. 

동치관계를 만족시키기 위한 다섯가지 요건이다.
1. 반사성
2. 대칭성
3. 추이성
4. 일관성
5. null-아님
    - 해당 규약은 내 코드에도 적용할 수 있을 것 같다!
    - `equals(null)` 대신 `instanceof` 사용하기
- [참고](https://sihyung92.oopy.io/java/effective-java/10)

## 양질의 equals() 구현 방법
1. `==` 연산자를 사용해 입력이 자기 자신의 참조인지 확인한다.
2. `instanceof` 연산자로 입력이 올바른 타입인지 확인한다.
    1. 묵시적 `null` 검사도 가능하다.
3. 입력을 올바른 타입으로 형변환한다.
4. 입력 객체와 자기 자신의 대응되는 핵심 필드들이 모두 일치하는지 검사한다.

**각 타입별 비교 방식**
- `float`와 `double`을 제외한 기본 타입 필드 : `== 연산자` 
- `참조 타입 필드` : 각각의 `equals()`
- `float`와 `double` 필드 : 각각 정적 메소드인 `compare()`
- `배열` 필드 : 원소 각각을 앞서의 지침대로 비교

- `float`와 `double`만 특별한 이유는, `Float.NaN`, `-0.0f`, `특수한 부동소수값`을 다루기 때문이다.
  - 얘네들도 `equals()` 를 사용할 수는 있지만, **오토박싱**이 수반될 수 있어 성능 상 좋지 않다.

`비교하기 복잡한 필드`의 경우, **그 필드의 표준형**을 저장해둔 후 표준형끼리 비교하여 경제적인 연산을 수행하도록 한다. 
→ 불변 클래스에 제격

또한, 필드 비교 순서가 equals()의 성능을 좌우하기도 한다.
- 당연히 다를 가능성이 큰 필드를 먼저 비교하는 것이 좋을 것이다.

> **모두 구현한 후 대칭성, 추이성, 일관성을 가지는지 확인한다.**
- 자문에서 그치지 않고, 테스트를 작성해보자.

**this**
```
인스턴스 자신을 가리키는 키워드이다.
```
- 객체의 해시키를 저장하고 있고 이는 JVM이 사용하는 참조변수 주소값이다.

```java
this : Room@404b9385
o : Room@404b9385
```

### 마지막 주의사항
**`equals()`를 재정의할 땐 `hashCode()`도 반드시 재정의하자.**
- `hashCode()` 는 `equals()` 비교에 사용되는 정보가 변경되지 않는 한, 항상 같은 값을 반환해야 한다.
- 이러한 의존성을 가지고 있기 때문에 재정의 시에 함께 재정의해야 한다는 것 같다.

**`Object` 외의 타입을 매개변수로 받지 않도록 하자.**
- 입력 타입이 `Object`가 아니므로 재정의가 아닌 **다중 정의(Overloading)**라고 한다.
  - `Object`의 `equals()`는 당연히 매개변수가 `Object`이다...!!!
  - `@Override` 어노테이션을 사용하면, **상위 클래스의 메소드를 재정의**할 수 있는데, 이때 상위 클래스 메소드의 매개변수를 따르지 않고 **다중 정의**해버리면, 컴파일 시에 오류 메세지를 날려 잘못되었다는 것을 알려준다!