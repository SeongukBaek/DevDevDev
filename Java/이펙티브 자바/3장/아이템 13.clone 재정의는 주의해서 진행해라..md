**TOC**
- [Cloneable과 그 문제점](#cloneable과-그-문제점)
  - [클래스가 가변 객체를 참조하는 경우 발생하는 문제점, 해결방법](#클래스가-가변-객체를-참조하는-경우-발생하는-문제점-해결방법)
    - [아이템 7의 `Stack`](#아이템-7의-stack)
    - [`해시테이블`](#해시테이블)
    - [고수준 API 활용](#고수준-api-활용)
- [Cloneable 구현 시 주의사항](#cloneable-구현-시-주의사항)
  - [예외 처리](#예외-처리)
  - [스레드 안전 클래스](#스레드-안전-클래스)
  - [요약](#요약)

# Cloneable과 그 문제점
`Cloneable`은 복제해도 되는 클래스임을 명시하는 **Mixin Interface**이다.

**Mixin?**
```
전통적인 다중상속을 클래스의 부분을 쪼개어 조립하는 것으로 대체하는 방식.
다른 클래스의 부모 클래스가 되지 않으면서 다른 클래스에서 사용할 수 있는 메소드를 포함하는 클래스.
```
- 이는 상속이 아니라 포함으로 설명된다.
- 코드 재사용성을 높이고, 상속의 모호성 문제(다이아몬드 문제)를 제거하거나, 다중상속에 대한 지원부족을 해결하기 위해 사용될 수 있다.

하지만 가장 큰 문제는 `clone()`이 선언된 곳이 `Object`이고, `protected`라는 것이다.
- 당연히 외부 객체에서 호출이 불가능하다.

**접근자**
```
객체의 멤버들에게 접근 제한을 걸 수 있는데, 이를 접근 제한자라 한다.
```

| 접근 제한자 | 적용 대상 | 접근 가능 대상 | 접근 불가 대상 |
| --- | --- | --- | --- |
| public | 클래스, 필드, 생성자, 메소드 | 모든 대상 | 없음 |
| protected | 필드, 생성자, 메소드 | 같은 패키지 또는 자식 클래스 | 자식 클래스가 아닌 다른 클래스에 소속된 클래스 |
| default | 클래스, 필드, 생성자, 메소드 | 같은 패키지에 소속된 클래스 | 다른 패키지에 소속된 클래스 |
| private | 필드, 생성자, 메소드 | 클래스 내부 | 클래스 외부 |
    
이 인터페이스가 하는 일은 `Object`의 `protected` 메소드인 `clone`의 동작 방식을 결정한다. 
- 이 인터페이스를 구현한 클래스의 인스턴스에서 `clone`을 호출하면 
  - 그 객체의 필드들을 하나하나 복사한 객체를 반환하며,
- 그렇지 않은 클래스의 인스턴스에서 호출하면
  - `CloneNotSupportedException`을 던진다.

보통, **인터페이스를 구현한다.** == **해당 클래스가 그 인터페이스에서 정의한 기능을 제공한다고 선언**함을 의미한다.

하지만 `Cloneable`은 상위 클래스에 정의된 `protected` 메소드의 동작 방식을 변경한다.
- 그리고 이를 구현한 클래스는 `public` 메소드로 `clone` 을 override 해야 한다.

> 일반 규약을 살펴보면, 강제성만 없을뿐 생성자 연쇄와 비슷한 매커니즘이다.

제대로 동작하는 `clone` 메소드를 가진 상위 클래스를 상속해 `Cloneable` 을 구현하는 경우
- `super.clone()`을 호출한다.
  - 이렇게 얻은 객체는 원본의 완벽한 복제본(값이 동일)

**super?**
```
부모 클래스로부터 상속 받은 필드나 메소드를 자식 클래스에서 참조할 때 사용하는 참조 변수
```
    
**공변 반환 타이핑?**
```
하위 클래스의 메소드가 상위 클래스의 메소드가 정의한 반환 타입이 아닌, 
하위 타입을 반환하는 기능
```
- 이를 통해 클라이언트가 형변환하지 않아도 된다.
    
**검사 예외와 비검사 예외?**
```
자바의 예외 처리는 모두 Throwable을 상속하고 있으며, 크게 Exception과 Error로 나뉜다.
Exception은 Checked형의 검사 예외이고, Error, RuntimeException은 UnChecked형의 비검사 예외이다.
```

**검사 예외?**
- 개발자가 명시해야 하는 부분, 컴파일 단계에 체크하고 처리하지 않으면 컴파일 에러가 발생한다.
- 과도한 예외 검출 → 시스템의 성능 저하
- 대표적으로 `IOException`, `SQLException`

**비검사 예외?**
- 컴파일러에게 걸리지지 않는다. 실행 중 발생하는 예외이다.
- 대표적으로 `NullPointerException`, `OutOfBoundsException`

`clone` 메소드는 사실상 생성자와 같은 효과를 낸다. 즉, **원본 객체에 아무런 해를 끼치지 않는 동시에 복제된 객체의 불변식을 보장해야 한다.**

## 클래스가 가변 객체를 참조하는 경우 발생하는 문제점, 해결방법
### 아이템 7의 `Stack`
정상적인 `clone` 메소드의 동작을 위해서는 스택 내부 정보를 복사해야 하고, 이를 위해 `elements` 배열의 `clone()` 을 재귀적으로 호출해야 한다.

하지만 이러한 방식으로도 해결되지 않는 경우가 있다.

### `해시테이블`
해시테이블 내부는 버킷들의 배열이고, 각 버킷은 키-값 쌍을 담는 연결 리스트의 첫 번째 엔트리를 참조한다.

스택처럼 단순히 재귀 호출을 한다면, 원본과 같은 연결리스트를 참조하여 예상치 못한 동작을 수행할 위험이 있다.
→ **각 버킷을 구성하는 연결 리스트를 복사해야 한다.**

이를 위해 **깊은 복사**를 지원하도록 한다!

> 재귀함수는 스택 오버 플로우의 위험성을 고려해야 한다. 이럴 때는 반복자를 사용하자.

### 고수준 API 활용
- `super.clone()`을 호출하여 얻은 객체의 모든 필드를 초기 상태로 설정한 다음,
- 원본 객체의 상태를 다시 생성하는 고수준 메소드들을 호출한다.
  - 해시테이블을 예로 들면, 싹 다 새로 `put()`하는 것이다.

# Cloneable 구현 시 주의사항
## 예외 처리
`Object`의 `clone` 메소드는 `CloneNotSupportedException`을 던진다고 선언했지만, 재정의한 메소드는 그렇지 않다.
- `public`인 `clone`메소드는 **검사 예외를 던지지 않도록 하여 사용의 편리성을 제공**해야 한다.

## 스레드 안전 클래스
`Cloneable`을 구현한 **스레드 안전 클래스**를 작성할 때는, `clone` 메소드 역시 적절히 동기화해줘야 한다.

## 요약
`Cloneable` 을 구현하는 모든 클래스는 `clone()` 을 재정의해야 하며,
- 접근 제한자는 `public`
- 반환 타입은 클래스 자신
- `super.clone()` 을 먼저 호출한 후, 필요한 필드를 모두 적절히 수정

하지만 이렇게 복잡한 경우는 드물기에, 아래의 방식을 사용할 수도 있다.

**복사 생성자?**
- 자신과 같은 클래스의 인스턴스를 인수로 받는 생성자

```java
public Yum(Yum yum) {...};
```

**복사 팩토리?**
- 복사 생성자를 모방한 정적 팩토리

```java
public static Yum newInstance(Yum yum) {...};
```

또한 복사 생성자와 복사 팩토리는 해당 클래스가 구현한 ‘인터페이스’ 타입의 인스턴스를 인수로 받을 수 있다.

그리고 이는 **변환 생성자**와 **변환 팩토리**라고 한다.
→ 그냥 형 변환을 자동으로 해주는 생성자와 팩토리