**TOC**
- [equals와 hashCode의 연관성](#equals와-hashcode의-연관성)
- [올바른 hashCode?](#올바른-hashcode)
  - [모든 객체에 대해 똑같은 해시코드를 반환하는 코드?](#모든-객체에-대해-똑같은-해시코드를-반환하는-코드)
  - [서로 다른 인스턴스에 서로 다른 해시코드를 반환하는 코드?](#서로-다른-인스턴스에-서로-다른-해시코드를-반환하는-코드)
    - [해시 코드 구현에서의 주의 사항](#해시-코드-구현에서의-주의-사항)
- [Objects의 hash()](#objects의-hash)
- [캐싱 활용](#캐싱-활용)

재정의하지 않으면 `hashCode`의 일반 규약을 어기게 되어 해당 클래스의 인스턴스를 `HashMap`이나 `HashSet` 같이 일반 규약을 지키고 있다고 가정하고 동작하는 클래스들에서 문제가 발생한다.

# equals와 hashCode의 연관성
다음은 hashCode에 대한 규약이다.

- equals 비교에 사용되는 정보가 변경되지 않았다면, 항상 그 객체의 hashCode는 같은 값을 반환해야 한다.
- equals로 두 객체를 같다고 판단했다면, 두 객체의 hashCode는 똑같은 값을 반환해야 한다.
- 다르다고 판단했다고 해도, hashCode 반환값도 반드시 다를 필요는 없다.
  - 하지만 다른 값을 반환해야 해시 테이블에서의 충돌을 피할 수 있다.

가장 중요한 부분이 2번째다. **논리적으로 같은 객체는 같은 `hashCode`를 반환**해야 한다.

```java
Map<PhoneNumber, String> m = new HashMap<>();
m.put(new PhoneNumber(707, 867, 5309), "bsu");

m.get(new PhoneNumber(707, 867, 5309))
// 결과는 null
```

- `null`인 이유는 당연히 2개의 서로 다른 인스턴스가 사용되었기 때문이다. 
  - `hashCode`를 재정의하여 **논리적 동치인 두 객체가 같은 해시코드를 반환**하도록 해야 한다.
- 그리고 `HashMap`은 해시코드가 다른 엔트리끼리는 동치성 비교를 시도조차 하지 않도록 최적화되어 있다!
  - HashMap의 get - getNode - hash 확인

# 올바른 hashCode?
그렇다면 올바른 `hashCode`는 어떤 모습일까?

## 모든 객체에 대해 똑같은 해시코드를 반환하는 코드?
- 적법하지만, 모든 객체가 해시테이블의 버킷 하나에 담겨 마치 **연결리스트**처럼 동작하게 될 것이다.
- 그렇게 되면, 평균 수행 시간이 O(1)인 해시테이블이 O(N)으로 느려져 성능에 좋지 못하다.

## 서로 다른 인스턴스에 서로 다른 해시코드를 반환하는 코드?
- `hashCode`의 세번째 규약이다!
- 이상적인 해시 함수는 주어진 인스턴스들을 32비트 정수 범위에 균일하게 분배해야 한다.

**좋은 hashCode를 작성하는 요령**
- 책 참고.

### 해시 코드 구현에서의 주의 사항
- 다른 필드로부터 계산해낼 수 있는 파생 필드는 해시코드 계산에서 제외해도 된다.
- 그리고 equals 비교에 사용되지 않는 필드는 “반드시“ 제외해야 한다.
  - 그렇지 않으면 두번째 규약을 어기게 될 수 있다.
- hashCode를 구현하는 요령 중 곱하는 숫자를 31로 한 이유는 홀수이기도 하면서 소수이기 때문이다.
  - 짝수이고 오버플로가 발생한다면 정보를 잃게 된다.
  - ??? **그렇다면 31이 아닌 다른 수를 사용하면 안되는 걸까? 큰 의미가 있는 걸까?**
    - 그렇지는 않다고 한다. 실제로 31이 아닌 다른 숫자를 사용하는 경우도 있다고 한다.
    - 시프트 연산과 뺄셈연산을 통해 데이터의 손실이 발생하지 않도록 하는 것이 가장 중요한 포인트이다.

```java
@Override
public int hashCode() {
		int result = Short.hashCode(areaCode);
		result = 31 * result + Short.hashCode(prefix);
		result = 31 * result + Short.hashCode(lineNum);
		return result;
}
```
- 3개의 핵심 필드에 대해 해시코드를 생성해 반환한다.
- 동치인 인스턴스들은 이제 같은 해시코드를 가질 것이다.

**구아바의 Hashing**
```
구글에서 만든 오픈 소스 라이브러리로, HashFunction을 제공하는 static 함수들을 선언하고 있다.
```

# Objects의 hash()
`Object` 클래스는 임의의 개수만큼 객체를 받아 해시코드를 계산해주는 정적 메소드인 `hash`를 제공한다.
- 이를 활용해 위에서 언급한 `hashCode()` 함수를 단 한 줄로 작성할 수 있다.
- 하지만 **속도는 더 느리다.**
  - 입력 인수를 담을 배열을 생성하고,
  - 입력 중 기본 타입이 있다면 박싱과 언박싱을 거쳐야 하기 때문이다.
  
→ 성능이 중요치 않은 상황에서 사용해야 한다.

# 캐싱 활용
클래스가 불변이고, 해시코드를 계산하는 비용이 크다면, 매번 새로 계산하기보단 **캐싱**을 사용하자.

- 이 타입의 객체가 주로 해시의 키로 사용될 것 같다면 인스턴스 생성 시에, 해시코드를 계산해둬야 한다.
- 그렇지 않다면 hashCode가 처음 호출될 때 계산하는 **지연 초기화** 방식을 사용해도 좋다.
  - 필드를 지연 초기화하려면 그 클래스를 **스레드 안전**하게 만들어야 한다.

> **성능을 높이려고 핵심 필드 계산을 제외해서는 안된다.**
- 해시의 품질이 떨어지는 길이다. 그리고 이는 곧 해시 테이블의 속도를 선형으로 떨어뜨릴 것이다.
  - 자바 2 전의 String에서의 해시

> hashCode가 반환하는 값의 생성 규칙을 API 사용자에게 자세히 알리지 말자.
- 그래야 클라이언트가 이 값에 의지하지 않게 되고, 추후 계산 방식을 바꿀 수도 있다.