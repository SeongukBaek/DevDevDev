**TOC**
- [compareTo()?](#compareto)
  - [compareTo의 일반 규약](#compareto의-일반-규약)
  - [compareTo() 작성 요령](#compareto-작성-요령)
    - [타입](#타입)
    - [객체 참조 필드](#객체-참조-필드)
    - [연산자](#연산자)
    - [순서](#순서)

# compareTo()?
`Comparable` 인터페이스의 `compareTo`는 `Object`의 메소드가 아니다!!!
- `compareTo`는 단순 동치성 비교에 더해 순서까지 비교할 수 있으며, 제네릭하다.
  - 해당 인터페이스를 구현했다. == 그 클래스의 인스턴스들은 순서가 있다.
- `compareTo` 값
  - -1 : 대상객체보다 주어진 객체의 값이 크다.
  - 0 : 두 값이 같다.
  - 1 : 대상객체보다 주어진 객체의 값이 더 작다.

> 자바 플랫폼 라이브러리의 **모든 값 클래스와 열거 타입이 `Comparable`을 구현했다.**

## compareTo의 일반 규약
`compareTo`는 `equals`와 마찬가지로 두 값을 비교하는 메소드이긴 하지만, 타입이 다른 객체에 대해 신경쓰지 않아도 된다.
- 그냥 `ClassCastException`을 던지면 된다.
- 하지만, `equals`와 비슷하게 **반사성, 대칭성, 추이성**을 충족해야 한다.
  - 그래서 같은 주의사항을 가지고, 같은 우회법을 가진다.
  - 확장 대신, 독립된 클래스를 만들고, 해당 클래스에 원래 클래스의 인스턴스를 가리키는 필드를 둔다.

`compareTo` 메소드로 수행한 동치성 테스트의 결과가 `equals` 와 같아야 한다는 마지막 규약을 잘 지키게 되면,
- `compareTo` 로 줄지은 순서와 `equals` 의 결과가 일관되게 된다.
- 일관되지 않아도 클래스의 동작에는 문제가 없지만, 특정 컬렉션에서는 `compareTo` 를 통해 정렬 시 동치성을 확인하기 때문에 주의가 필요하다.

다음은 그러한 예이다.
- `new BigDecimal(”1.0”)`,  `new BigDecimal(”1.00”)` 은 `equals`는 `false` 지만, `HashSet` 에 넣는 경우 1개의 원소만 갖게 된다.

## compareTo() 작성 요령
### 타입
`Comparable` 은 타입을 인수로 받는 제네릭 인터페이스이므로, `compareTo` 의 인수 타입은 컴파일 시점에 정해진다.
- 따라서 타입에 대해 크게 확인할 필요가 없다.

### 객체 참조 필드
`compareTo` 메소드는 각 필드의 동치성을 비교하는 것이 아닌 그 순서를 비교한다.
- 객체 참조 필드의 비교는 `compareTo` 의 재귀 호출로 수행한다.
- `Comparator`는 `Comparable`을 구현하지 않은 필드나 표준이 아닌 순서로 비교해야 하는 경우 사용한다.

**Comparable**
```
compareTo(T o)라는 메소드 하나만을 가진 인터페이스
```
- 자기 자신과 매개변수 객체를 비교한다.

**Comparator**
```
실질적으로 compareTo(T o1, T o2)만 구현하면 되는 인터페이스
왜냐면 다른 메소드들은 일반 메소드로, 이미 구현되어 있음.
```
- 두 매개변수 객체를 비교한다. (즉, 자기 자신은 고려되지 않음.)

### 연산자
또한 `compareTo` 메소드에서 필드의 값을 비교할 때는 `<`, `>` 연산자는 사용하지 않도록 하자.
- 대신, 박싱된 기본 타입 클래스가 제공하는 **정적 compare 메소드**나, Comparator 인터페이스가 제공하는 **비교자 생성 메소드**를 사용하자.

### 순서
`equals` 와 유사하게, 핵심 필드를 기준으로 비교하도록 하자.

자바 8에서는 `Comparator` 인터페이스가 비교자 생성 메소드와 함께 메소드 연쇄 방식으로 비교자를 생성할 수 있게 되었다고 한다.
- 약간의 성능 저하 발생.
- 좀 더 간결하고 깔끔한 코드.

> 해시코드 값의 차를 기준으로 하는 비교자는 추이성을 위배한다.
> - 이처럼, 값의 차를 기준으로 하는 비교는 정수 오버플로나 부동소수점 계산 방식에 따른 오류가 있을 수 있으니 주의해야 한다. -> 최대한 하지 않도록 하자.
> - 이런 경우는 **박싱된 기본 타입의 정적 compare**(ex. `Integer.compare()`, ...)나, **비교자 생성 메소드**(ex. `Comparator.comparingInt()`, ...)를 활용해야 한다.