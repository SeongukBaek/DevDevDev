> wait, notify 는 올바르게 사용하기 까다로워졌다. 자바 5에서부터 도입된 고수준 동시성 유틸리티를 사용하자.

java.util.concurrent 의 범주
- 실행자 프레임워크
- 동시성 컬렉션 : 표준 컬렉션 인터페이스에 동시성을 구현한 컬렉션 (내부에서 동기화 수행 => 동기화 무력화는 불가능 + 외부 락 추가 사용 시 성능 매우 저하)
- 동기화 장치

동시성 컬렉션 -> 동시성 무력화 불가 -> 여러 메소드를 묶어 원자적 호출 불가 => **여러 기본 동작을 하나의 원자적 동작으로 묶는 '상태 의존적 수정' 메소드 추가!**
- ex. `putIfAbsent`

이러한 동시성 컬렉션의 등장은, 동기화한 컬렉션을 낡은 유산으로 만들었다.
- `Collections.synchronizedMap` 대신, `ConcurrentHashMap` 을 사용하자.

컬렉션 인터페이스 중 일부는 작업이 성공적으로 완료될 때까지 차단된다.
- ex. `BlockingQueue.take()` : 큐의 첫 원소를 꺼낸다. 큐가 빈 경우, 새로운 원소가 추가될 때까지 대기
- 이는 **작업 큐**로 쓰기 적합해진 형태 (앞에서 등장했던 `ThreadPoolExecutor` 를 포함한 대부분의 실행자 서비스가 이 큐를 사용)

동기화 장치는 스레드가 다른 스레드를 기다릴 수 있도록 한다.
- 자주 사용 : CountDownLatch, Semaphore
- 가장 강력 : Phaser

CountDownLatch : 일회성 장벽, 하나 이상의 스레드가 또 다른 하나 이상의 스레드 작업이 끝날 때까지 대기하도록 한다.
- 전달받은 count 값으로 대기 중인 스레드를 깨울지 결정

> 시간 간격 측정 시, 좀 더 정확하고 정밀한 System.nanoTime 을 사용하자.

`wait` 메소드 : 스레드가 특정 조건이 충족되기를 기다리게 할 때 사용
- 그 객체를 잠근 동기화 영역 안에서 사용해야 한다.
- 또한 반드시 대기 반복문 관용구를 사용해야 한다.
  - 해당 반복문이 wait 호출 전후로 조건 만족 여부를 검사한다.
