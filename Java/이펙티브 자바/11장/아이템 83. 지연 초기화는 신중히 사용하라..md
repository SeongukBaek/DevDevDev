지연 초기화 : 필드의 초기화 시점을 그 값이 처음 필요할 때까지 늦추는 기법.
- 주로 최적화 용도로 사용되지만, 클래스와 인스턴스 초기화 때 발생하는 순환 참조 문제를 해결하는데도 사용된다.

하지만 이러한 지연 초기화도 성능에 영향을 끼칠 수가 있다.
- 클래스 혹은 인스턴스 생성에 대한 초기화 비용은 줄지만, 그 필드에 접근하는 비용이 커진다.
- 초기화가 이뤄지는 비율에 따라, 실제 초기화에 드는 비용에 따라, 초기화된 각 필드를 얼마나 빈번히 호출하느냐에 따라 성능에 영향을 끼칠 수 있다.

**지연 초기화가 필요할 때**
- 클래스의 인스턴스 중, 그 필드를 사용하는 인스턴스의 비율이 낮은 반면, 그 필드를 초기화하는 비용이 큰 경우 => 진짜 필요할때만 초기화하는 것이 유리하기 때문.
  - 하지만 정말 유리한 지 알려면 지연 초기화 적용 전후로 비교하긴 해야 함.
 
**멀티 스레드 환경에서의 지연 초기화**
- 둘 이상의 스레드가 해당 필드를 공유한다면, 지연 초기화에 대한 동기화가 필요하다.

> 대부분 상황에서, 일반적인 초기화가 지연 초기화보다 낫다.

멀티 스레드 환경에서, **지연 초기화가 순환 참조를 발생**시킬 것 같다면, `synchronized` 를 적용하자.
- 필드를 초기화하는 메소드에 `synchronized` 접근자를 적용하라는 의미.

성능으로 인해 정적 필드를 지연 초기화하려 한다면, **지연 초기화 홀더 클래스 관용구**를 사용하자.
- 클래스는 클래스가 처음 쓰일 때 초기화된다는 특성을 이용한 것.

```java
// 정적 내부 클래스 : 외부 클래스가 로드될 때 함께 로드
private static class FieldHolder {
    // 정적 내부 클래스 안의 정적 필드 : 처음 접근되는 시점에 초기화, 즉 getField 가 호출될 때 초기화
    static final FieldType field = computeFieldValue();
}

private static FieldType getField() { return FieldHolder.field; }
```
- **GPT 설명** : 정적 내부 클래스(static nested class)는 외부 클래스가 로드될 때 함께 로드되지만, 그 내부의 정적 필드(initialization-on-demand holder idiom)는 외부 클래스의 정적 필드가 처음 접근되는 시점에 초기화됩니다. 이는 JVM의 클래스 로딩 및 초기화 메커니즘에 기반한 동작입니다.
- 또한 위 방식에서는 동기화가 필요하지 않으므로 성능에서도 이점이 있다.

성능으로 인해 인스턴스 필드를 지연 초기화해야 한다면, **이중검사 관용구**를 사용하라.
- 필드의 값을, 동기화 없이 검사하고, 필드가 아직 초기화되지 않았다면 동기화하여 검사하는 방식
  - 두번째 검사에서도 초기화되지 않았다면, 필드를 초기화한다.
  - 초기화 이후에는 동기화하지 않기 때문에 `volatile` 를 적용해야 한다. (해당 한정자는 항상 가장 최근에 기록된 값을 읽도록 보장하기 때문)
- 단일 검사 : 초기화 여부 검사 이후, 초기화되지 않았다면 바로 초기화하는 방식. (필드를 여러번 초기화해도 상관 없는 경우)
