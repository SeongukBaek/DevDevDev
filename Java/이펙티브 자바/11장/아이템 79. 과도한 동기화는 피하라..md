과도한 동기화 => 성능 저하, 교착상태 발생, 예측불가한 동작 낳기.

**응답 불가와 안전 실패를 피하려면, 동기화 메소드나 동기화 블록 안에서는 제어를 절대로 클라이언트에 양도하면 안된다.**
- 즉, 동기화 영역 안에서는 재정의 가능 메소드를 호출하면 안되고, (재정의해서 클라이언트가 어떻게 할 지 모르니까.)
- 클라이언트가 넘겨준 함수 객체를 호출해서도 안된다.
- 이들은 모두, 동기화된 영역에 예외나 교착상태를 발생시키거나, 데이터를 훼손시킬 수 있다.

해결 방법
- 외계인 메소드 호출을 동기화 블록 바깥으로 옮기기. (== **열린 호출**)
  - 열린 호출을 통해 얼마나 걸릴 지 모르는 외계인 메소드로 인한 다른 스레드들의 대기를 방지해준다. -> 동시성 효율 개선

**기본 규칙 : 동기화 영역에서는 가능한 한 일을 적게 하는 것**
- 동기화 영역에서는, 락을 얻고, 공유 데이터를 검사하고, 필요하면 수정하고, 락을 해제하는 작업이 이뤄진다.
- 오래 걸리는 작업이라면 동기화 영역 바깥으로 옮기는 것을 고려하자.

**동기화 비용** ==> 스레드 간 경쟁으로 낭비하는 시간, 즉 병렬로 실행할 기회를 잃고 모든 코어가 메모리를 일관되게 보기 위한 지연 시간
- 추가로 가상머신의 코드 최적화를 제한한다는 것 또한 과도한 동기화의 비용

가변 클래스를 만드려는 경우, 주의사항
1. 동기화를 하지 말고, 그 클래스를 동시에 사용해야 하는 클래스가 외부에서 알아서 동기화하게 하자.
2. 동기화를 내부에서 수행해 스레드 안전한 클래스로 만들자.
    - 클라이언트가 외부에서 객체 전체에 락을 거는 것보다 동시성을 월등히 개선할 수 있을 때만 사용
    - 락 분할, 락 스트라이핑, 비차단 동시성 제어와 같은 기법들 동원

> `StringBuffer`, `StringBuilder`
> - StringBuffer 는 거의 단일 스레드에서만 사용되었음에도 내부적으로 동기화를 수행함. -> 매우 불필요한 작업
> - StringBuilder 가 등장하게 된 배경
> - Random -> ThreadLocalRandom 도 비슷한 이유

**CopyOnWriteArrayList**
: 추가, 수정, 삭제와 같은 쓰기 연산 시 리스트의 복사본을 만들어 수행
- 동작 방식 (by. GPT)

<img width="735" alt="스크린샷 2024-06-10 20 44 19" src="https://github.com/SeongukBaek/DevDevDev/assets/33208303/c13be741-ae81-4551-a9be-cf2f010aea10">
