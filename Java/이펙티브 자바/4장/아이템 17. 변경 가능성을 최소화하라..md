**TOC**
- [불변 클래스](#불변-클래스)
  - [클래스를 불변으로 만들기.](#클래스를-불변으로-만들기)
- [불변 클래스 장점](#불변-클래스-장점)
  - [불변 클래스 - 함수형 프로그래밍에서의 활용](#불변-클래스---함수형-프로그래밍에서의-활용)
  - [불변 객체는 단순하다.](#불변-객체는-단순하다)
  - [불변 객체는 근본적으로 스레드 안전하다.](#불변-객체는-근본적으로-스레드-안전하다)
  - [불변 객체는 방어적 복사도 필요없다.](#불변-객체는-방어적-복사도-필요없다)
  - [불변 객체는 공유 뿐만 아니라 불변 객체끼리는 내부 데이터를 공유할 수 있다.](#불변-객체는-공유-뿐만-아니라-불변-객체끼리는-내부-데이터를-공유할-수-있다)
  - [객체 생성 시, 구성요소로 불변 객체들을 사용하자.](#객체-생성-시-구성요소로-불변-객체들을-사용하자)
  - [불변 객체는 그 자체로 실패 원자성을 제공한다.](#불변-객체는-그-자체로-실패-원자성을-제공한다)
- [불변 클래스 단점](#불변-클래스-단점)
  - [값이 다르면 반드시 독립된 객체로 만들어야 한다.](#값이-다르면-반드시-독립된-객체로-만들어야-한다)
    - [1. 다단계 연산들을 예측하여 기본 기능으로 제공하는 방법](#1-다단계-연산들을-예측하여-기본-기능으로-제공하는-방법)
    - [2. 해당 클래스를 `public`으로 제공하는 방법\*\*](#2-해당-클래스를-public으로-제공하는-방법)
- [불변 클래스를 만드는 또 다른 설계 방법](#불변-클래스를-만드는-또-다른-설계-방법)
  - [자신을 상속하지 못하게 하는 더 유연한 방법](#자신을-상속하지-못하게-하는-더-유연한-방법)
  - [필드를 캐싱해서 사용하기.](#필드를-캐싱해서-사용하기)
- [정리](#정리)

# 불변 클래스
불변 클래스란 그 인스턴스의 내부 값을 수정할 수 없는 클래스.
- 불변 인스턴스에 간직된 정보는 고정되어 **객체가 파괴되는 순간**까지 절대 달라지지 않는다.
- `String`, `기본 타입의 박싱된 클래스들`, `BigInteger`, `BigDecimal`이 여기에 속한다.
- 가변 클래스보다 설계와 구현, 사용이 쉬우며, 오류가 생길 여지도 적어 안전하다.

## 클래스를 불변으로 만들기.
클래스를 불변으로 만들려면 어떻게 해야할까?

- **객체의 상태를 변경하는 메소드를 제공하지 않는다.**
  - 객체 상태가 `public` 이면 변경될 수 있지 않을까
  - 따라서 다음 규칙이 등장한다.
- **클래스를 확장할 수 없도록 한다.**
  - 간단하게 말해 상속을 막는다.
  - 이를 위해 클래스를 `final` 로 선언하는 방법이 있다. 뒤에 더 나옴
- **모든 필드를 `final` 로 선언한다.**
  - 요래 해놓으면 설계자가 이건 절대 수정하면 안된다는 의도를 내비추는 것
  - 새로 생성된 인스턴스를 동기화없이 다른 스레드로 건네도 문제없이 동작하게끔 보장하는데도 필요하다.
- **모든 필드를 `private` 으로 선언한다.**
  - 클라이언트에서의 직접 접근을 막는다.
  - 기본 타입 필드나 불변 객체를 참조하는 필드를 `public final` 로만 선언해도 불변 객체가 되지만, 이렇게 하면 다음 단계에서 내부 표현을 바꾸지 못하므로 추천하지 않음.
- **자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.**
  - 클래스에 가변 객체를 참조하는 필드가 하나라도 있다면, 클라이언트에서 그 객체의 참조를 얻을 수 없도록 해야 한다.
    - 참조를 얻게 되어 클라이언트가 제공한 객체 참조로 바꿀 수도 있으니.
  - 그리고 접근자 메소드(getter)가 이 필드를 그대로 반환해서도 안된다
  - 모두 **방어적 복사**를 수행해야 한다! (객체를 반환하는 메소드의 경우(생성자, 접근자, readObject))

# 불변 클래스 장점
## 불변 클래스 - 함수형 프로그래밍에서의 활용
실수부와 허수부 값을 저장하는 불변 필드를 가진 **불변 복소수 클래스**가 있다고 가정.
- 실수부와 허수부 값을 반환하는 접근자 메소드와 사칙연산 메소드들을 정의하고 있다.
  - 하지만 인스턴스 자신은 수정하지 않고, **새로운 인스턴스를 만들어 반환**한다.
- 이처럼 피연산자에 함수를 적용해 그 결과를 반환하지만, 피연산자 자체는 그대로인 패턴을 **함수형 프로그래밍**이라 한다.
  - 또한 메소드만 봐도, 전치사만을 사용해 함수형 프로그래밍의 네이밍을 사용했다고 볼 수 있다.

> 이와 달리 절차적 혹은 명령형 프로그래밍에서는 메소드에서 피연산자인 자신을 수정해 상태가 변하게 된다.

> 함수형 프로그래밍의 코드는 불변이 되는 영역의 비율을 높일 수 있다.

## 불변 객체는 단순하다.
- 생성된 시점의 상태를 파괴될 때까지 그대로 간직한다.
- 반면 가변 객체는 임의의 복잡한 상태에 놓일 수 있다. → 메소드들이 변경시키면 의도치 않은 값을 가질 수 있다.

## 불변 객체는 근본적으로 스레드 안전하다.
- 따라서 동기화할 필요가 없어, 안심하고 공유할 수 있다.
- 불변 클래스라면 한 번 만든 인스턴스를 최대한 재활용하기를 권장한다.
  - 자주 쓰이는 값들을 상수(`public static final`) 로 제공하는 것이다!
- 혹은 자주 사용되는 인스턴스를 캐싱하여 같은 인스턴스를 중복 생성하지 않게 해주는 정적 팩토리를 제공할 수 있다.
  - 박싱된 기본 타입 클래스 전부와 `BigInteger` 가 속한다.
    - 상당히 많은 상수 필드를 가지고 있다.
  - 이를 통해 인스턴스 공유가 가능해져, 메모리 사용량과 가비지 컬렉션 비용에서의 장점이 있다.

## 불변 객체는 방어적 복사도 필요없다.
- 복사해도 결국 원본과 같기 때문이다!
- 따라서 불변 클래스는 `clone` 메소드나 복사 생성자를 제공하지 않는게 좋다.

## 불변 객체는 공유 뿐만 아니라 불변 객체끼리는 내부 데이터를 공유할 수 있다.
- ex. `BigInteger` 의 부호와 크기
  - 부호와 크기를 서로 다른 필드로 저장
  - 주어진 `BigInteger` 와 크기가 같고 부호만 반대인 새로운 `BigInteger` 를 생성하는 `negate()` 에서는 `크기` 필드를 원본과 공유해서 사용한다.

## 객체 생성 시, 구성요소로 불변 객체들을 사용하자.
객체를 만들 때 **다른 불변 객체들을 구성요소로 사용**하면 이점이 많다.
- 그 구조가 아무리 복잡해도 불변식을 유지하기가 훨씬 수월하기 때문이다!
- ex. 맵의 키, 집합의 원소
  - 맵이나 집합은 내부 값이 바뀌면 불변식이 허물어진다.
  - 하지만 불변 객체는 값이 바뀔 일이 없다.

## 불변 객체는 그 자체로 실패 원자성을 제공한다.
- 상태가 변하지 않아 불일치 상태에 빠질 일이 아예 없다.
- 실패 원자성 : 메소드에서 예외가 발생한 후에도 그 객체는 여전히 유효한 상태여야 한다는 성질.

# 불변 클래스 단점
## 값이 다르면 반드시 독립된 객체로 만들어야 한다.
- 값의 종류가 많다면 이들을 모두 만드는 비용이 들 것이다.

원하는 객체를 완성하기까지의 단계가 많고, 중간 단계에서 만들어진 객체들이 모두 버려진다면 성능 문제는 더 심해진다.
- 불완전한 객체이기도 하다.

이를 해결할 방법은 2가지다.

### 1. 다단계 연산들을 예측하여 기본 기능으로 제공하는 방법
- 이를 통해 각 단계마다 객체를 생성할 필요가 없어진다.
- ex. `BigInteger`는 모듈러 지수 같은 다단계 연산 속도를 높여주는 **가변 동반 클래스**를 `package-private`으로 두고 있다.

**가변 동반 클래스?**
```
주로 불변 클래스가 비즈니스 로직 연산 등 
시간 복잡도가 높은 연산 시 불필요한 클래스 생성을 막기 위해 내부적으로 사용하는 클래스
```

### 2. 해당 클래스를 `public`으로 제공하는 방법**
- 자바 플랫폼 라이브러리에서 이에 해당하는 클래스가 `String`
- `String` 의 가변 동반 클래스 - `StringBuffer` , `StringBuilder`

# 불변 클래스를 만드는 또 다른 설계 방법
## 자신을 상속하지 못하게 하는 더 유연한 방법
- `final` 클래스로 선언하는 것 말고 더 유연한 방법이 있다.

모든 생성자를 `private` 혹은 `package-private`으로 만들고, `public` 정적 팩토리를 제공하는 것이다.
- 패키지 외부에서 볼 수 없는 `package-private` 구현 클래스를 원하는 만큼 만들어 활용 가능해 유연하다.
- 사실상 이 불변 객체는 `final`이다.
  - 왜냐면, 외부에서 접근 가능한 생성자가 없기 때문이다. → 이는 곧 **확장의 불가능**을 의미한다.

> BigInteger, BigDecimal -> 설계 당시 잘못된 생각으로 인해, 정상적인 불변 객체임을 보장할 수 없다.

## 필드를 캐싱해서 사용하기.
불변 클래스의 규칙 목록을 따르면, **모든 필드가 `final`이고, 어떤 메소드도 그 객체를 수정할 수 없어야 한다.**
- 성능을 위해 조금 완화한다면, 
**“어떤 메소드도 객체의 상태 중 외부에 비치는 값을 변경할 수 없다”** 라고 할 수 있다.
- 어떤 불변 클래스는 계산 비용이 큰 값을 나중에 계산하여 `final` 이 아닌 필드에 캐시하기도 한다.
  - 그리고 이를 반환하도록 하여 계산 비용을 절감한다.

# 정리 
> Getter가 있다고 해서 Setter를 무조건 만들지 말자.
- **클래스는 꼭 필요한 경우가 아니라면 불변이어야 한다.**

> 단순한 값 객체는 불변으로 만들자.

> 무거운 값 객체도 불변으로 만들 수 있는지 고민하자.
- 성능때문에 어쩔 수 없다면 **불변 클래스와 쌍을 이루는 가변 동반 클래스를 public 클래스로 제공하자.**

> 불변으로 만들 수 없는 클래스라도, 변경할 수 있는 부분을 최소한으로 줄이자. 
- 즉 최대한 필드를 `private final`로 선언하자.

> 생성자는 불변식 설정이 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야 한다.