**TOC**
- [정보 은닉](#정보-은닉)
  - [정보 은닉을 위한 자바의 매커니즘](#정보-은닉을-위한-자바의-매커니즘)
  - [접근성 제한에 대한 제약](#접근성-제한에-대한-제약)
  - [접근성 관련 주의사항](#접근성-관련-주의사항)
    - [public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다.](#public-클래스의-인스턴스-필드는-되도록-public이-아니어야-한다)
    - [길이가 0이 아닌 배열은 모두 변경의 위험이 있다.](#길이가-0이-아닌-배열은-모두-변경의-위험이-있다)
- [모듈 시스템의 등장으로 추가된 암묵적 접근 수준](#모듈-시스템의-등장으로-추가된-암묵적-접근-수준)

# 정보 은닉
> 설계가 잘됐고 못됐고의 차이는 클래스 내부 데이터와 내부 구현 정보를 외부 컴포넌트로부터 얼마나 잘 숨겼느냐다!
- 오직 API를 통해서만 소통하는 것이 좋은 설계

=> **정보 은닉** 혹은 **캡슐화**

**정보 은닉의 이점**
- 시스템을 구성하는 컴포넌트를 독립시켜 개발, 테스트, 최적화, 적용, 분석, 수정을 개별적으로 할 수 있게 해준다.
- 시스템 개발 및 유지보수 효율성 증가
- 간접적인 성능 최적화 도움
- 재사용성의 향상

## 정보 은닉을 위한 자바의 매커니즘
접근 제어 매커니즘
- 클래스, 인터페이스, 멤버의 접근성을 명시
- 각 요소의 접근성은 **그 요소가 선언된 위치**와 **접근 제한자**로 정해진다.

> **기본 원칙 : 모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다.**

**톱레벨 클래스**와 **인터페이스**에 부여할 수 있는 접근 수준
- `package-private(= default)` : 해당 패키지 안에서만 사용
- `public` : 공개 API

한 클래스에서만 사용하는 `package-private` 톱레벨 클래스나 인터페이스는, 이를 **사용하는 클래스 안에 `private static`으로 중첩**시켜보자.
- 이를 통해 바깥 클래스 하나에서만 접근할 수 있게 된다. (이를 사용하는 클래스를 의미)
- 이 또한 접근 범위를 줄일 수 있는 행위 중 하나.
- 하지만 이보다 더 중요한 것은, `public` 일 필요가 없는 클래스의 접근 수준을 `package-private` 으로 제한하는 것.

멤버(필드, 메소드, 중첩 클래스, 중첩 인터페이스)에 부여할 수 있는 접근 수준은 4가지다.

| 접근 수준 | 설명 |
| --- | --- |
| private | 멤버를 선언한 톱레벨 클래스에서만 접근할 수 있다. |
| package-private(default) | 멤버가 소속된 패키지 안의 모든 클래스에서 접근할 수 있다. 단, 인터페이스의 멤버는 기본적으로 public이 적용된다. |
| protected | package-private의 접근 범위를 포함하며, 이 멤버를 선언한 클래스의 하위 클래스에서도 접근할 수 있다. |
| public | 모두 접근 |

## 접근성 제한에 대한 제약
상위 클래스의 메소드를 재정의할 때는 그 접근 수준을 상위 클래스에서보다 좁게 설정할 수 없다!
- 이는 상위 클래스의 인스턴스는 하위 클래스의 인스턴스로 대체해 사용할 수 있어야 한다는 **리스코프 치환 원칙**을 지키기 위해 필요하다.
  - 즉 상위 클래스에서는 접근할 수 있도록 해야한다는 말 .. ?
  - 만약 `public` 으로 선언된 상위 클래스의 메소드를 재정의할 때는, `private` 이나 `package-private` 으로 재정의할 수 없다는 의미.

## 접근성 관련 주의사항
### public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다.
- 필드가 가변 객체를 참조하거나, `final` 이 아닌 인스턴스 필드를 `public` 으로 선언하면 그 필드에 담을 수 있는 값을 제한할 힘을 잃는다. → 아무나 접근할 수 있기 때문에, **불변식을 보장할 수 없다!**
- 또한, 필드가 수정될 때 다른 작업(락 획득 같은)을 할 수 없게 되므로, `public` 가변 필드를 갖는 클래스는 **일반적으로 스레드 안전하지 않다.**
- 심지어 필드가 `final` 이면서 불변 객체를 참조하더라도 문제는 여전히 남는다?
  - 왜 남는가? `final` 이면 수정 불가고, 불변 객체를 참조하면 문제가 없지 않나 …
  - **Final이라도 변경가능한 방법이 없는 것은 아니다!**

**예외**
- 클래스가 표현하는 추상 개념을 완성하는 데 꼭 필요한 구성요소로서의 상수인 경우 **public static final** 필드로 공개해도 좋다.
- 그리고 이런 필드는 반드시 기본 타입 값이나 불변 객체를 참조해야 한다.
  - 만약 가변 객체를 참조한다면, 다른 객체를 참조할 수 없더라도, 참조된 객체 자체가 수정될 수 있다.

### 길이가 0이 아닌 배열은 모두 변경의 위험이 있다.
- 클래스에서 `public static final` 배열 필드를 두거나, **이 필드를 반환하는 접근자 메소드를 제공해서는 안된다.**
  - 그 배열 안의 값은 `final` 이 아니기 때문에 그대로 수정될 수 있다.

이를 해결하기 위해서, 2가지 해결책이 있다.
- 해당 배열을 **`public` 불변 리스트**에 추가한다.
  - `public static final List<> VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES))`
  - 해당 클래스의 모든 삽입, 수정 메소드는 예외를 발생시킨다.
- **방어적 복사**
  - 원본 배열의 복사본을 반환하는 public 메소드 생성

# 모듈 시스템의 등장으로 추가된 암묵적 접근 수준
자바 9에서는 **모듈 시스템**이라는 개념이 도입되었다.
- 두 가지 암묵적 접근 수준도 추가되었다.
- 패키지가 클래스들의 묶음이듯, 모듈은 패키지들의 묶음이다.

**[자바 9 모듈 시스템](https://www.baeldung.com/java-9-modularity)**
```
패키지의 상위 단계로, 코드의 재사용성을 높여주기 위해 만들어진 자바 플랫폼 시스템
```

모듈은 자신에 속하는 패키지 중 공개(`export`)할 것들을 선언한다.
- `protected` 혹은 `public` 멤버라도 **해당 패키지를 공개하지 않았다면** 모듈 외부에서의 접근은 불가능하다.
  - **즉 모듈 내부로 한정되는 접근자가 된다!**
- 이를 활용하면 클래스를 외부에 공개하지 않으면서도 같은 모듈을 이루는 패키지 사이에서는 자유롭게 공유할 수 있다.