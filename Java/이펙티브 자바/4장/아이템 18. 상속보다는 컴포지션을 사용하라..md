**TOC**
- []()

# 상속.
**상속은 코드를 재사용하는 강력한 수단이다.**
- 하지만 잘못하면 오류를 내기 쉬운 SW를 만들게 된다.

일반적인 구체 클래스를 패키지 경계를 넘어, **다른 패키지의 구체 클래스를 상속하는 일은 위험**하다.

> 여기서 상속은, **클래스가 다른 클래스**를 확장하는 구현 상속 의미

# 상속의 문제점
## 메소드 호출과 달리 상속은 캡슐화를 깨뜨린다.
상위 클래스가 어떻게 구현되느냐에 따라 하위 클래스의 동작에 이상이 생길 수 있다.
- 상위 클래스가 다음 릴리즈에서 변경되면, 하나도 수정하지 않은 하위 클래스에서 문제가 발생할 수 있다.

> `HashSet` 의 `addAll()` 은 내부적으로 `add()` 를 사용하는 자기사용 구현방식을 취한다.
> - 이러한 구현 방식이 다음 버전에서는 변경될 수도, 계속 유지될 수도 있고, 이는 클라이언트 코드로 하여금 깨지기 쉬운 코드를 만들도록 한다.

하위 클래스가 깨지기 쉬운 이유는 더 있다.
- 다음 릴리스에서 상위 클래스에 새로운 메소드가 추가되는 경우.
- 보안 때문에 컬렉션에 추가된 모든 원소가 특정 조건을 만족해야만 하는 프로그램이 있다고 가정
  - 그 컬렉션을 상속하여 원소를 추가하는 모든 메소드를 재정의해 필요한 조건을 검사하도록 구현해서, 상위 클래스에 대해 하위 클래스를 변경했다.
  - 하지만 상위 클래스에 또 다른 원소 추가 메소드가 만들어지면, 더 이상 통하지 않는다.
  - 하위 클래스에서 이 새로운 메소드를 재정의하지 못하면 **허용되지 않은 원소**를 추가할 수 있게 된다.

그렇다면 메소드를 재정의하는 방식이 아니라, **새로운 메소드를 추가**하면 문제가 되지 않을까 싶지만, 
- 만약 상위 클래스에 추가된 새 메소드가 **하위 클래스에 추가한 메소드와 같고 반환 타입만 다르다면** 컴파일조차 되지 않는다.
  - 혹 반환 타입마저 같다면 `Override` 한 거나 마찬가지다…

# 문제를 해결할 방법
기존 클래스를 확장하는 대신, 새로운 클래스를 만들고 **`private` 필드로 기존 클래스의 인스턴스를 참조**하게 하자!
- **컴포지션**(기존 클래스가 새로운 클래스의 구성요소로 쓰임)을 수행하자.
- 새 클래스의 인스턴스 메소드들은 **내부에 필드로 존재하는 기존 클래스의 메소드를 호출**한다.
  - 이를 **전달(forwarding)**이라 하며, 새 클래스의 메소드들을 **전달 메소드(forwarding method)**라 한다.
  - 이를 통해 새로운 클래스는 기존 클래스의 내부 구현 방식의 영향에서 벗어나며, 심지어 기존 클래스에 새로운 메소드가 추가되더라도 전혀 영향이 없다!

**Delegation (위임)**
```
Composition과 Forwarding이 합쳐진 개념
```
엄연히 Composition과 다른 개념이다. 오히려 상위 개념?
- 엄밀히는 래퍼 객체가 내부 객체에 자기 자신의 참조를 넘기는 경우만 위임에 해당한다.

다른 인스턴스를 감싸고 있는 클래스를 **래퍼 클래스**라고 하고, 
다른 인스턴스에 계측 기능을 덧씌우는 패턴을 **[데코레이터 패턴](https://refactoring.guru/ko/design-patterns/decorator)**이라고 한다.

> **래퍼 클래스는 콜백 프레임워크와는 어울리지 않는다.**

**콜백 프레임워크?**
```
GUI 프레임워크가 해당되는데, 특정 이벤트 발생 시, 
핸들러로 작업을 전달하는 프레임워크
```

콜백 프레임워크에서는 **자기 자신의 참조를 다른 객체에 넘겨 다음 호출 때 사용**하도록 한다.
- 내부 객체는 자신을 감싸고 있는 래퍼의 존재를 모르기에 대신 **자신(`this`)의 참조**를 넘기고,
콜백 때는 래퍼가 아닌 내부 객체를 호출하게 된다.
  - 이를 **SELF 문제**라고 한다.

# 상속을 써야할 때.
**상속**은 반드시 하위 클래스가 상위 클래스의 **‘진짜’ 하위 타입**인 상황에서만 쓰여야 한다.
- 즉 `IS-A` 관계가 성립할 때만! 그렇지 않으면 상속하지 말자.

## 잘못된 예시들
`Stack` 은 `Vector` 를 상속하고 있는데,
- `Stack` 은 `Vector` 가 아니다. -> `IS - A` 관계가 아니므로 상속해선 안됐다.

`Properties` 또한 `Hashtable` 이 아니다.
- 따라서 상속해선 안됐다.

## 컴포지션 대신 상속을 잘못 쓴 경우
컴포지션을 써야 할 상황에서 상속을 사용하는 건, **내부 구현을 불필요하게 노출하는 꼴**이다.
- 이로 인해 API가 내부 구현에 묶이고, 클래스의 성능 또한 제한된다.
- 또한 클라이언트가 노출된 내부에 직접 접근할 수 있게 된다는 점이다.

그리고 이로 인해 클라이언트에서 **상위 클래스를 직접 수정**하여 **하위 클래스의 불변식을 해칠 수 있다.**
- `Properties.getProperty()` & `Hashtable.get()`

> **컴포지션 대신 상속을 사용하려 할 때의 자문**
> : ”확장하려는 클래스의 API에 아무런 결함이 없나 ?”

> 상속은 상위 클래스의 모든 점, 즉 결함까지도 그대로 가져간다는 점을 알자.