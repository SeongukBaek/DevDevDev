**TOC**
- [추상 클래스보다 인터페이스를 우선해야 하는 이유.](#추상-클래스보다-인터페이스를-우선해야-하는-이유)
  - [기존 클래스에도 손쉽게 새로운 인터페이스를 구현해넣을 수 있다.(`implements`)](#기존-클래스에도-손쉽게-새로운-인터페이스를-구현해넣을-수-있다implements)
  - [인터페이스는 믹스인(mixin) 정의에 안성맞춤이다.](#인터페이스는-믹스인mixin-정의에-안성맞춤이다)
  - [인터페이스로는 계층 구조가 없는 타입 프레임워크를 만들 수 있다.](#인터페이스로는-계층-구조가-없는-타입-프레임워크를-만들-수-있다)
  - [래퍼 클래스 관용구와 함께 사용하면 인터페이스는 기능을 향상시키는 안전하고 강력한 수단이 된다.](#래퍼-클래스-관용구와-함께-사용하면-인터페이스는-기능을-향상시키는-안전하고-강력한-수단이-된다)
  - [디폴트 메소드](#디폴트-메소드)
    - [디폴트 메소드의 제약.](#디폴트-메소드의-제약)
  - [인터페이스와 추상 골격 구현 클래스 활용](#인터페이스와-추상-골격-구현-클래스-활용)
    - [골격 구현 클래스](#골격-구현-클래스)

자바가 제공하는 다중 구현 매커니즘은 **인터페이스**와 **추상 클래스**다.
- 자바 8부터는 **인터페이스도 디폴트 메소드를 제공**할 수 있어 두 매커니즘 모두 인스턴스 메소드를 구현 형태로 제공할 수 있다.

**둘의 가장 큰 차이**는, 
추상 클래스가 정의한 타입을 구현하는 클래스는 반드시 **추상 클래스의 하위 클래스**가 되어야 한다는 점이다.
- 자바는 단일 상속만 지원하니, 추상 클래스 방식은 새로운 타입을 정의하는데 제약이 생긴다.

반면 인터페이스가 선언한 메소드를 모두 정의하고, 일반 규약을 잘 지킨 클래스라면 다른 어떤 클래스를 상속했든 **같은 타입으로 취급**된다.

# 추상 클래스보다 인터페이스를 우선해야 하는 이유.
## 기존 클래스에도 손쉽게 새로운 인터페이스를 구현해넣을 수 있다.(`implements`)
기존 클래스는 인터페이스가 요구하는 메소드를 추가하고, `implements` 만 추가하면 새로운 인터페이스를 구현해넣을 수 있다.

반면 기존 클래스 위에 새로운 추상 클래스를 끼워넣기는 일반적으로 어렵다.
- 두 클래스가 같은 추상 클래스를 확장하길 원한다면, 그 추상 클래스는 계층구조상 두 클래스의 공통 조상이어야 한다.
  - 기존 계층 구조에 혼란을 야기.

## 인터페이스는 믹스인(mixin) 정의에 안성맞춤이다.
믹스인이란, 클래스가 구현할 수 있는 타입으로, 믹스인을 구현한 클래스에 **원래의 “주된 타입” 외**에도 **특정 선택적 행위를 제공**한다고 선언하는 효과를 준다. (다중 상속의 해결방안이 되기도 한다!)

하지만 **추상 클래스로는 믹스인을 정의할 수 없다.**
- 기존 클래스에 덧씌울 수 없기 때문이다!
  - 클래스는 다중상속이 불가능하고, 클래스 계층 구조에는 믹스인을 삽입할 위치가 없다!

## 인터페이스로는 계층 구조가 없는 타입 프레임워크를 만들 수 있다.
**타입을 계층적으로 정의**하면 수많은 개념을 구조적으로 잘 표현할 수 있지만, 
현실에서는 계층을 엄격히 구분하기 어려운 개념도 있다.
- 가수 인터페이스, 작곡가 인터페이스, 이 두 인터페이스를 모두 구현해도 문제되지 않는다.
- 이처럼 인터페이스는 타입을 인터페이스로 정의해도 문제가 되지 않는다.

인터페이스가 아닌 클래스로 유연한 설계를 하려 한다면, **조합 폭발**이라 부르는 현상이 발생할 것이다.

**조합 폭발?**
```
클래스 폭발이라고 하며, 상속의 남용으로 하나의 기능을 추가하기 위해 필요 이상으로
많은 수의 클래스를 추가해야 하는 경우를 말한다.
```
    
## 래퍼 클래스 관용구와 함께 사용하면 인터페이스는 기능을 향상시키는 안전하고 강력한 수단이 된다.
타입을 추상 클래스로 정의해두면 그 타입에 기능을 추가하는 방법은 **상속**뿐이다!
- 상속을 통해 만든 클래스는 래퍼 클래스보다 활용도가 떨어지고 깨지기 더 쉽다.

## 디폴트 메소드
인터페이스의 메소드 중 구현 방법이 명백한 것이 있다면, 이를 디폴트 메소드로 제공하고 문서화해야 한다.

### 디폴트 메소드의 제약.
- 내가 만든 인터페이스에만 디폴트 메소드를 추가할 수 있다.
- 하지만 `equals`와 `hashCode` 같은 `Object`의 메소드를 많은 인터페이스가 정의하고 있지만, 이를 디폴트 메소드로 제공할 수는 없다.
  - **왜 안될까**

> 또한 인터페이스는 인스턴스 필드를 가질 수 없고, `public`이 아닌 정적 멤버도 가질 수 없다. (`private` 정적 메소드 예외!)

## 인터페이스와 추상 골격 구현 클래스 활용
위 방식으로, 인터페이스와 추상 클래스의 장점을 모두 취하는 방법도 있다.
- 인터페이스로는 타입을 정의하고, 필요한 경우 디폴트 메소드로 몇 개 제공한다.
- 골격 구현 클래스는 나머지 메소드들까지 구현한다.

→ 골격 구현을 확장하는 것으로 이 인터페이스를 구현하는 것이 대부분 완료된다. 그리고 이는 **템플릿 메소드 패턴**이 된다.

**추상 골격 구현?**
```
인터페이스와 추상 클래스의 이점을 모두 취할 수 있는 디자인
```

**템플릿 메소드 패턴?**
```
특정 작업을 처리하는 일부분을 하위 클래스로 캡슐화하여 전체적인 구조는 바꾸지 않으면서
특정 단계에서 수행하는 내용을 바꾸는 패턴
```
    
추상 골격 구현의 예로는 `AbstractSet`, `AbstractMap`, `AbstractList`가 있다. 이들은 컬렉션 인터페이스의 골격 구현이다.

### 골격 구현 클래스
**추상 클래스처럼 구현을 도와주는** 동시에, **추상 클래스로 타입을 정의할 때 따라오는 제약에서 자유롭다**는 이점이 있다.
- 골격 구현을 확장하는 것으로 인터페이스 구현이 거의 끝나긴 하지만, 강제적인 방법은 아니다.
- 구조상 골격 구현을 확장하지 못하는 처지(이미 다른 클래스를 상속 중?)라면 인터페이스를 직접 구현해야 한다.
  - 이런 경우라도 인터페이스가 제공하는 디폴트 메소드를 사용하면 된다.
- 또한 우회방법이 있다.
  - 인터페이스를 구현한 클래스에서 해당 골격 내부 구현을 확장한 `private` 내부 클래스를 정의하고, 각 메소드 호출을 내부 클래스의 인스턴스에 전달하는 것이다.
  - => **시뮬레이트한 다중 상속**

**골격 구현 작성!**
- 인터페이스를 잘 살펴 다른 메소드들의 구현에 사용되는 기반 메소드들을 선정
  - 골격 구현에서는 추상 메소드가 될 것.
- 기반 메소드들을 사용해 직접 구현할 수 있는 메소드를 모두 디폴트 메소드로 제공
    - Object의 메소드는 안됨! 왜 ??? → 골격 구현 클래스에서 이를 재정의해야 하기 때문? 즉, 하위 클래스에서 재정의가 필요한 메소드들이기 때문?
    - 만약 인터페이스의 모든 메소드가 기반 메소드와 디폴트 메소드가 된다면 골격 구현은 필요 없다.
- 남은 메소드는 이 인터페이스를 구현하는 골격 구현 클래스를 하나 만들어 작성

**단순 구현**은 골격 구현의 작은 변종이다.
- 골격 구현처럼 상속을 위해 인터페이스를 구현한 것이지만, 추상 클래스가 아니다!