**TOC**
- [상속을 위한 설계: 재정의 가능 메소드에 대한 문서화](#상속을-위한-설계-재정의-가능-메소드에-대한-문서화)
- [상속을 위한 설계: protected 메소드로 공개](#상속을-위한-설계-protected-메소드로-공개)
  - [어떤 경우에 protected로 공개하지?](#어떤-경우에-protected로-공개하지)
- [상속을 위한 설계: 클래스의 생성자, 재정의 가능 메소드 호출 금지.](#상속을-위한-설계-클래스의-생성자-재정의-가능-메소드-호출-금지)
- [상속을 위한 설계: `Cloneable`과 `Serializable` 인터페이스 상속 시, 주의](#상속을-위한-설계-cloneable과-serializable-인터페이스-상속-시-주의)
- [상속을 위한 설계: 일반 구체 클래스는 상속 금지](#상속을-위한-설계-일반-구체-클래스는-상속-금지)
  - [표준 인터페이스를 구현하지 않은 구체 클래스](#표준-인터페이스를-구현하지-않은-구체-클래스)
    - [기계적인 방법](#기계적인-방법)

> 메소드를 재정의하면 어떤 일이 일어나는지를 정확히 정리하여 문서로 남겨야 한다.

# 상속을 위한 설계: 재정의 가능 메소드에 대한 문서화
**상속용 클래스는 재정의할 수 있는 메소드들을 내부적으로 어떻게 이용하는지(자기사용) 문서로 남겨야 한다.**
- 어떤 순서로 호출하는지, 각각의 호출 결과가 이어지는 처리에 어떤 영향을 주는지도 담아야 한다.
  - “재정의 가능”이라는 `public` 과 `protected` 메소드 중 `final` 이 아닌 모든 메소드!
- 재정의 가능 메소드를 호출할 수 있는 모든 상황을 문서로 남겨야 한다.
  - 백그라운드 스레드나 정적 초기화 과정에서도 호출이 일어날 수 있다.

> API 문서 메소드 설명에서 “Implementation Requirements”가 메소드의 내부 동작 방식을 설명하는 부분
- 이는 메소드 주석에 `@implSpec` 태그를 붙여주면 자바독 도구가 생성해준다!

**책의 좋은 문서화의 예시**를 확인하면, 메소드의 동작이 어떤 결과를 낳고, 어떤 에러가 발생할 수 있는지를 알려주고 있다.
- `AbstractCollection.remove()`

> 격언: 좋은 API 문서란 '어떻게'가 아닌 '무엇'을 하는지를 설명해야 한다.
- 하지만 메소드 내부 동작을 설명하는 문서를 보면, 해당 메소드가 '어떻게' 동작하는지를 설명하고 있다.
- 이는 모두 상속이 재정의 가능 메소드로 인해 캡슐화를 해치기 때문에 일어나는 현실이다.

# 상속을 위한 설계: protected 메소드로 공개
**내부 메커니즘을 문서로 남기는 것**만이 상속을 위한 설계의 전부는 아니다.
- 효율적인 하위 클래스를 큰 어려움 없이 만들 수 있게 하려면 클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅(`hook`)을 잘 선별하여 `protected` 메소드 형태로 공개해야 할 수도 있다.
- `AbstractList.removeRange()`
- 해당 메소드는 `protected` 인데, 이는 `AbstractList` 의 하위 클래스들이 사용할 `clear()` 메소드에서 사용되기 때문에, 해당 메소드의 성능 개선을 위해 `protected` 로 공개되었다.

## 어떤 경우에 protected로 공개하지?
**상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어보는 것이 “유일”하다.**
- 이를 통해 꼭 필요한 `protected` 멤버와 전혀 필요없는 `private`이어야 할 멤버를 구분할 수 있을 것이다.
- **배포 전 검증 과정**을 꼭 거쳐 클래스의 성능과 기능에 영원한 족쇄를 채우지 않도록 하자.

# 상속을 위한 설계: 클래스의 생성자, 재정의 가능 메소드 호출 금지.
**상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메소드를 호출해서는 안된다!**
- **상위 클래스의 생성자가 하위 클래스의 생성자보다 먼저 실행**되기에 하위 클래스에서 재정의한 메소드가 하위 클래스의 생성자보다 먼저 호출된다.
  - 이때 하위 클래스가 재정의한 메소드가 하위 클래스의 생성자에서 초기화하는 값에 의존한다면 동작은 의도대로 되지 않을 것이다.

> 하위 클래스의 생성자 호출 → 상위 클래스의 생성자 호출 → 상위 클래스 생성자: 해당 클래스의 재정의 가능 메소드 호출 → 상위 클래스의 메소드가 재정의되었음, 따라서 하위 클래스의 재정의된 메소드 호출
- 해당 예시에서는 `final` 필드의 상태가 2가지일 수 있는 문제가 있다.

# 상속을 위한 설계: `Cloneable`과 `Serializable` 인터페이스 상속 시, 주의
- 둘 중 하나라도 구현한 클래스를 상속할 수 있도록 하지 말자.
  - 확장하려는 사용자에게 부담스러운 작업 → `Cloneable`은 아이템 13에서 언급!

`clone`과 `readObject` 메소드는 생성자와 비슷하게 새로운 객체를 만들어 비슷한 효과가 있다.
- 따라서, 바로 직전에 언급되었듯, **이 두 메소드 모두 간접, 직접적으로 재정의 가능 메소드를 호출해서는 안된다.**

`Serializable`을 구현한 상속용 클래스가 `readResolve`나 `writeReplace` 메소드를 갖는다면, 이 메소드들은 `private`이 아닌 `protected`로 선언해야 한다.
- 하위 클래스에서 무시되지 않기 위함이다.

> 참고로 **`Serializable` 인터페이스를 구현한 클래스는 싱글톤일 수 없다.** 직렬화를 통해 초기화해둔 인스턴스가 아닌 다른 인스턴스가 반환되기 때문이다.

**`writeObject`, `readObject`**
```
자바 직렬화, 역직렬화 과정에서 별도 처리가 필요할 때 사용하는 메소드
```

`writeObject` → 직렬화 과정, `readObject` → 역직렬화 과정에서 자동으로 호출된다.
- 이들은 `private`으로 선언되어 있다. 그렇지 않으면 자동 호출되지 않는다.
  - 즉, 재정의하지 못하도록 되어 있다.

`Serializable` 인터페이스를 구현한 클래스는 싱글톤일 수 없다고 했다. 그렇다면 싱글톤을 보장할 방법은 없을까
- 바로 아래의 메소드들을 사용하면 된다!
    
**`readResolve`**
```
역직렬화 과정에서,
만들어진 인스턴스 대신 기존에 생성된 싱글톤 인스턴스를 반환하도록 정의하여
자동으로 호출되는 readObject 메소드 대신 이 메소드의 인스턴스를 반환하도록 대체
```

**`writeReplace`**
```
직렬화 과정에서 readResolve와 비슷한 역할을 수행한다.
```

# 상속을 위한 설계: 일반 구체 클래스는 상속 금지
일반적인 구체 클래스는 전통적으로 `final`도 아니고, 상속용으로 설계되거나 문서화되지도 않았다.
- 하지만 그렇다고 해서 위험하지 않은 것은 절대 아니다.
- 구체 클래스 내부만 수정했음에도 확장한 클래스에서 문제가 발생하는 경우가 드물지 않다.

**상속용으로 설계하지 않은 클래스는 상속을 금지하여 문제를 해결할 수 있다.**

상속을 금지하는 방법으로는 다음과 같다.
- 클래스를 `final`로 선언하는 방법
- 모든 생성자를 `private`이나 `package-private`으로 선언하고, `public` 정적 팩토리를 제공하는 방법

## 표준 인터페이스를 구현하지 않은 구체 클래스
그럼에도 상속을 필요로 한다면, 클래스 내부에서는 재정의 가능 메소드를 호출하는 자기 사용 코드를 모두 없애고, 이를 문서로 남겨라.

### 기계적인 방법
- 각각의 재정의 가능 메소드는 자신의 본문 코드를 private '도우미 메소드'로 옮기고,
- 이 도우미 메소드를 호출하도록 수정
- 재정의 가능 메소드를 호출하는 다른 코드들도 모두 이 도우미 메소드를 직접 호출하도록 수정