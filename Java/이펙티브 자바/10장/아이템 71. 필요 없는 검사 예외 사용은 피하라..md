**검사 예외**는 개발자로 하여금 해당 API를 사용했을 때 발생할 수 있는 문제를 알리고, 이를 처리(`catch` 사용)할 수 있도록 강제하여, 프로그램의 안전성을 높인다.
- 물론 과하면, 쓰기 불편할 것.

> 자바 8부터는 스트림 안에서 검사 예외를 던지는 메소드를 사용할 수 없다.

그렇다면 비검사 예외는 언제 사용하는 것이 좋을까?
- 개발자가 그 예외를 어떻게 다룰지 생각해보자.

```java
} catch (TheCheckedException e) {
  throw new AssertionError();
}
```

```java
// 더 나은 방식
} catch (TheCheckedException e) {
  e.printStackTrace();
  System.exit(1);
}
```

검사 예외를 회피하는 가장 쉬운 방법 : **적절한 결과 타입을 담은 옵셔널을 반환하자.**
- 검사 예외 대신, 빈 옵셔널을 반환하도록 구현
  - 단점 : 예외 발생 이유를 전달해줄 수 없다.

또 다른 방법 : **검사 예외를 던지는 메소드를 2개로 쪼개, 비검사 예외로 바꾸자.**

```java
try {
  obj.action(args);
} catch (TheCheckedException e) {
  // 예외 상황 처리
}
```

```java
if (obj.actionPermitted(args)) {
  obj.action(args);
} else {
  // 예외 상황 처리
}
```
- `actionPermitted()` 메소드를 통해 미리 예외가 발생할지 여부를 확인하는 방식.
  - 상태 검사 메소드에 해당.
  - 상태 검사 메소드는 동시성 문제에서 단점 존재
- 좀 더 유연한 방식.

> **정리**
> : 개발자가 예외 상황에서 복구할 방법이 없다면 비검사 예외를 던지자. 복구가 가능하고, 호출자가 그 처리를 하는 것을 요구한다면, 먼저 옵셔널 반환 여부를 고민하자. 옵셔널만으로는 처리에 필요한 정보가 불충분하다면, 검사 예외를 던지자.
