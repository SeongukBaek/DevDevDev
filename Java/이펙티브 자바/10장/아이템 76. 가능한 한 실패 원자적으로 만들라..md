**호출된 메소드가 실패하더라도, 해당 객체는 메소드 호출 전 상태를 유지해야 한다.**
- 이를 실패 원자적인 특성이라고 한다.

어떻게 메소드를 실패 원자적으로 만들 수 있을까?
- **불변 객체로 설계하자.** 불변 객체는 태생적으로 **실패 원자적**이다.
- 왜냐면 불변 객체의 상태는, **생성 시점에 고정되어 절대 변하지 않기 때문**이다.

그렇다면 가변 객체의 경우는 어떨까?
- **작업 수행에 앞서 매개변수의 유효성을 검사하자.**
  - 객체 내부 상태 변경 전, 잠재적 예외의 가능성을 걸러내는 방법

**ex. 스택의 `pop()` 에서, 현재 `size` 가 0인지 확인.**
```java
public Object pop() {
  if (size == 0) {
    throw new EmptyStackException();
  }
  Object result = elements[--size];
  ...
}
```
- 여기서 if 문을 제거해도, 예외가 던져지는 것은 동일하지만, 그 다음 줄이 주요하다.
  - `--size` 을 통해 `size` 가 변경되었기 때문에, 예외가 던져진 후, 다시 `pop` 을 호출한 경우에 또 메소드를 실패하게 만든다.
  - 그리고 이때 던져지는 `IndexOutOfBoundsException` 은 추상화 수준이 현재 상황에 맞지 않는다.

또 다른 방법
- **객체의 임시 복사본에서 작업을 수행한 다음, 작업이 성공하면 원래 객체와 교체하는 것이다.**
  - 주로 데이터를 임시 자료구조에 저장해 작업하는 것이 더 빠른 경우 사용 
  - ex. 정렬 메소드에서 정렬을 수행하기 전, 입력 리스트의 원소들을 배열로 옮겨 담아 정렬하는 방식.
  - 이를 통해, 정렬에 실패해도 입력 리스트의 상태는 변하지 않는다.
 
마지막 방법
- 작업 도중 발생하는 실패를 가로채는 복구 코드를 작성해, 작업 전 상태로 되돌리자.
- 주로 내구성 보장이 필요한 자료구조에 사용. 자주 안 쓰이는 방법

**실패 원자성은 항상 달성할 수는 없다.**
- ex. 두 스레드가 동기화 없이 같은 객체를 동시 수정한다면 일관성이 깨질 것이다.
  - `ConcurrentModificationException` 을 잡아냈다고 해도, 그 객체가 여전히 쓸 수 있는 상태라고 가정해서는 안된다.
- `Error` 는 복구할 수 없는 것이므로 애초에 실패 원자성을 고려할 필요가 없다.
- 또한 실패 원자성 달성을 위한 비용이나 연산이 복잡한 경우, 항상 실패 원자적으로 만들 필요도 없다.
