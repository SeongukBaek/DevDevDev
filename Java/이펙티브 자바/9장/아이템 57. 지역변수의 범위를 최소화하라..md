**TOC**
- [가장 처음 쓰일 때 선언](#가장-처음-쓰일-때-선언)
- [거의 모든 지역변수는 선언과 동시에 초기화](#거의-모든-지역변수는-선언과-동시에-초기화)
- [반복자를 사용하는 경우, 전통적인 for문이 낫다](#반복자를-사용하는-경우,-전통적인-for문이-낫다)
- [메소드를 작게 유지하고 한 가지 기능에 집중](#메소드를-작게-유지하고-한-가지-기능에-집중)

> 아이템 15 "클래스와 멤버의 접근 권한을 최소화하라" 와 비슷한 취지의 아이템.

# 가장 처음 쓰일 때 선언
미리 선언해두면 코드 가독성이 떨어지게 된다.
- 또한 실제 사용하는 시점에서는 타입과 초깃값이 떠오르지 않을 수 있다.

지역 변수의 범위는 선언된 지점부터 그 지점을 포함한 블록이 끝날 때까지이다.
- 따라서 이 범위를 고려해서 쓸데없이 오래 살아남지 않도록 하자.

# 거의 모든 지역변수는 선언과 동시에 초기화
만약 선언 시 초기화를 위한 정보가 충분치 않다면, 선언을 미뤄야 한다.
- try-catch 문에서는 예외로, 변수 선언 시 검사 예외가 던져질 수 있다면 try 블록 안에서 초기화해야 한다.
- try 블록 밖에서도 해당 변수를 사용해야 한다면, 블록 바로 앞에서 선언해야 한다.

반복문의 경우, 반복문이 종료된 후에도 반복 변수의 값을 사용할 것이 아니라면, 반복문 몸체에서만 반복 변수가 유효한 for 문을 쓰는 것이 낫다.

# 반복자를 사용하는 경우, 전통적인 for문이 낫다
for-each 문을 사용하게 되면, for문이 잡아줄 수 있는 컴파일 타임 오류를 놓칠 수 있게 된다.
- **솔직히 해당 이슈는 코드 작성자가 잘 찾기만 하면 범할 일이 없는 문제이므로, 넘어가도 될 것 같다.**

```java
Iterator<Element> i = c.iterator();
while (i.hasNext()) {
    doSomething(i.next());
}

// 위 코드를 복사/붙여넣기 하여 다른 컬렉션을 순회하려는 경우, while 문 안의 조건을 수정해주지 않아도, 즉 i.hasNext() 를 그대로 사용해도 컴파일 오류가 발생하지 않을 것이다.
// 하지만 for 문의 경우, 반복 변수의 범위가 해당 반복문으로 제한되기 때문에, 곧바로 컴파일 오류가 발생할 것이다.
```

**for문의 장점**

```java
for (int i = 0, n = expensiveComputation(); i < n; i++) {
    doSomething(i);
}
```
- 변수 i의 범위 계산을 반복문 선언부에서 저장하기 때문에, 매 반복마다 불필요한 계산을 없앨 수 있다.

# 메소드를 작게 유지하고 한 가지 기능에 집중
메소드에서 여러 가지 기능을 수행하면, 그 중 하나의 기능에만 관여하는 지역 변수라도, 다른 기능을 수행하는 코드에서 접근이 가능하게 된다.
- 메소드를 여러 개로 분리해서, 하나의 지역 변수의 범위를 최소화하자.
