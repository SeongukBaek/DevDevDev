**리플렉션** : 프로그램에서 임의이 클래스에 접근할 수 있는 기능.
- 클래스의 생성자, 메소드, 필드에 해당하는 인스턴스 접근 가능.
- 이 인스턴스들을 통해 클래스의 멤버 이름, 필드 타입, 메소드 시그니처 등의 정보를 가져올 수 있다.
- 또한, 각각에 연결된 실제 생성자, 메소드, 필드를 조작할 수도 있다.

리플렉션을 사용하면, 컴파일 시에 존재하지 않던 클래스도 이용할 수 있다. 하지만 다음과 같은 단점이 있다.

**컴파일 타임에 잡히지 않기에, 컴파일 타임 타입 검사의 이점을 누리지 못한다.**
- 예외 검사도 마찬가지.
- 런타임 오류에 취약

**코드가 지저분하고 장황해진다.**

**성능이 떨어진다.**
- 아마 가장 큰 단점이지 않을까.
- 성능이 느린 원인 중 하나로, Reflection을 통한 초기 호출 시 JVM이 해당 정보를 미리 최적화할 수 없는 문제가 있다.

**아주 제한된 형태로만 사용해야 단점을 피하고 이점만 취할 수 있다.**
- 컴파일타임에 사용할 수 없는 클래스를 사용하는 경우라면, 적절한 인터페이스나 상위 클래스로 선언하고, 인스턴스 생성 시에만 리플렉션을 사용하도록 하자.

**`Set<String>` 인터페이스의 인스턴스를 생성하는 코드**
- 정확한 구현 클래스는 명령줄의 첫 번째 인수로 확정.
- 위 코드는 리플렉션의 2가지 단점을 명확히 보인다. (클래스의 생성에서만 발견되는 단점!, 생성 이후에는 리플렉션을 사용하지 않는 코드와 다를 것이 없다.)
  1. 런타임동안 많은 예외를 던질 수 있다. 따라서 이에 대한 try - catch 문을 작성해야 한다.
     - 모든 리플렉션 예외의 상위 클래스인 `ReflectiveOperationException` 을 통해 코드 길이를 줄일 수는 있다.
  2. 첫번째 단점과 연관되는 단점으로, 클래스 이름만으로 생성자를 호출하기 위해 수 많은 줄의 코드가 필요하다.

리플렉션을 사용해본 경험은, 커스텀 어노테이션을 생성해서, 런타임에 해당 어노테이션이 적용된 클래스의 필드에 접근해 값을 가져오고, 값을 수정하는 작업 시, 사용해보았다.
- 사용했을 때의 느낀 점은, 책에서도 언급했듯 컴파일 타임에서 잡아주지 못하는 예외들이 많다는 점이다. 그리고 이로 인해 코드가 길어지게 되고, 런타임에 발생할 내가 모르는 예외들에 대해 취약해서, 100% 안전한 코드라고 하기 어렵다는 점이다.

**출처**
- https://lob-dev.tistory.com/44
